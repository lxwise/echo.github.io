{"meta":{"title":"不曾留得桃花影","subtitle":null,"description":null,"author":"echo","url":"http://39.99.158.50","root":"/"},"pages":[{"title":"categories","date":"2020-04-14T07:31:42.937Z","updated":"2020-04-14T07:31:42.937Z","comments":true,"path":"categories/index.html","permalink":"http://39.99.158.50/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-04-14T05:53:12.000Z","updated":"2020-04-14T05:53:12.899Z","comments":true,"path":"categories/index-1.html","permalink":"http://39.99.158.50/categories/index-1.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-04-24T14:16:03.000Z","updated":"2020-04-24T14:16:18.841Z","comments":true,"path":"friends/index.html","permalink":"http://39.99.158.50/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-04-14T05:51:58.000Z","updated":"2020-04-14T05:51:58.386Z","comments":true,"path":"tags/index-1.html","permalink":"http://39.99.158.50/tags/index-1.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"about","date":"2020-04-14T05:54:18.000Z","updated":"2020-04-14T07:35:39.212Z","comments":true,"path":"about/index.html","permalink":"http://39.99.158.50/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"Tags","date":"2020-04-14T07:36:01.558Z","updated":"2020-04-14T07:36:01.558Z","comments":false,"path":"tags/index.html","permalink":"http://39.99.158.50/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-04-24T19:26:24.000Z","updated":"2020-04-24T19:26:24.219Z","comments":true,"path":"contact/index-1.html","permalink":"http://39.99.158.50/contact/index-1.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-04-24T14:15:06.000Z","updated":"2020-04-24T14:15:49.876Z","comments":true,"path":"contact/index.html","permalink":"http://39.99.158.50/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"","slug":"15redis笔记","date":"2020-05-10T06:26:45.598Z","updated":"2020-05-10T06:26:20.248Z","comments":true,"path":"2020/05/10/15redis-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/15redis-bi-ji/","excerpt":"","text":"1234567891011121314151617title: redis复习（十五）author: echodate: 2020-05-10 16:23:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - redis - 复习tags: - redis - 复习 [TOC] 今日内容1. redis 1. 概念 2. 下载安装 3. 命令操作 1. 数据结构 4. 持久化操作 5. 使用Java客户端操作redis Redis1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库 1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品 • 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 2. 下载安装 1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 3. 命令操作 1. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username \"zhangsan\" 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username \"lisi\" * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) \"username\" 2) \"lisi\" 3) \"password\" 4) \"123\" 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) \"b\" 2) \"a\" 3) \"c\" 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) \"a\" 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) \"lisi\" 2) \"zhangsan\" 3) \"wangwu\" 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) \"zhangsan\" 2) \"60\" 3) \"wangwu\" 4) \"80\" 5) \"lisi\" 6) \"500\" 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 7. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 4. 持久化 1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 5. Java客户端 Jedis * Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(\"localhost\",6379); //2. 操作 jedis.set(\"username\",\"zhangsan\"); //3. 关闭连接 jedis.close(); ​ * Jedis操作各种redis中的数据结构 1) 字符串类型 string set get //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 //存储 jedis.set(\"username\",\"zhangsan\"); //获取 String username = jedis.get(\"username\"); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(\"activecode\",20,\"hehe\");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 hset hget hgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // 存储hash jedis.hset(\"user\",\"name\",\"lisi\"); jedis.hset(\"user\",\"age\",\"23\"); jedis.hset(\"user\",\"gender\",\"female\"); // 获取hash String name = jedis.hget(\"user\", \"name\"); System.out.println(name); ​ // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(“user”); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) { //获取value String value = user.get(key); System.out.println(key + \":\" + value); } //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // list 存储 jedis.lpush(\"mylist\",\"a\",\"b\",\"c\");//从左边存 jedis.rpush(\"mylist\",\"a\",\"b\",\"c\");//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(\"mylist\", 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(\"mylist\");//c System.out.println(element1); String element2 = jedis.rpop(\"mylist\");//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(\"mylist\", 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 ​ // set 存储 jedis.sadd(“myset”,”java”,”php”,”c++”); // set 获取 Set&lt;String&gt; myset = jedis.smembers(\"myset\"); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // sortedset 存储 jedis.zadd(\"mysortedset\",3,\"亚瑟\"); jedis.zadd(\"mysortedset\",30,\"后裔\"); jedis.zadd(\"mysortedset\",55,\"孙悟空\"); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(\"mysortedset\", 0, -1); System.out.println(mysortedset); ​ //3. 关闭连接 jedis.close(); ​ * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,\"localhost\",6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(\"hehe\",\"heihei\"); ​ //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(\"jedis.properties\"); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(\"maxTotal\"))); config.setMaxIdle(Integer.parseInt(pro.getProperty(\"maxIdle\"))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(\"host\"),Integer.parseInt(pro.getProperty(\"port\"))); ​​ } ​ /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); } } 案例：案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 * 注意：使用redis缓存一些不经常发生变化的数据。 * 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。 ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"14Ajax&Json笔记","date":"2020-05-10T06:26:45.593Z","updated":"2020-05-10T06:25:35.358Z","comments":true,"path":"2020/05/10/14ajax-json-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/14ajax-json-bi-ji/","excerpt":"","text":"12345678910111213141516171819title: AJAX&amp;&amp;JSON复习（十四）author: echodate: 2020-05-10 16:13:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - AJAX - JSON - 复习tags: - AJAX - JSON - 复习 [TOC] 今日内容1. AJAX： 2. JSON AJAX：1. 概念： ASynchronous JavaScript And XML 异步的JavaScript 和 XML 1. 异步和同步：客户端和服务器端相互通信的基础上 * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 提升用户的体验 2. 实现方式： 1. 原生的JS实现方式（了解） //1.创建核心对象 var xmlhttp; if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); } else {// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); } //2. 建立连接 /* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */ xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true); //3.发送请求 xmlhttp.send(); //4.接受并处理来自服务器的响应结果 //获取方式 ：xmlhttp.responseText //什么时候获取？当服务器响应成功后再获取 //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。 xmlhttp.onreadystatechange=function() { //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); } } 2. JQeury实现方式 1. $.ajax() * 语法：$.ajax({键值对}); //使用$.ajax()发送异步请求 $.ajax({ url:\"ajaxServlet1111\" , // 请求路径 type:\"POST\" , //请求方式 //data: \"username=jack&amp;age=23\",//请求参数 data:{\"username\":\"jack\",\"age\":23}, success:function (data) { alert(data); },//响应成功后的回调函数 error:function () { alert(\"出错啦...\") },//表示如果请求响应出现错误，会执行的回调函数 dataType:\"text\"//设置接受到的响应数据的格式 }); 2. $.get()：发送get请求 * 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 3. $.post()：发送post请求 * 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 JSON：1. 概念： JavaScript Object Notation JavaScript对象表示法 Person p = new Person(); p.setName(\"张三\"); p.setAge(23); p.setGender(\"男\"); var p = {\"name\":\"张三\",\"age\":23,\"gender\":\"男\"}; * json现在多用于存储和交换文本信息的语法 * 进行数据的传输 * JSON 比 XML 更小、更快，更易解析。 2. 语法： 1. 基本规则 * 数据在名称/值对中：json数据是由键值对构成的 * 键用引号(单双都行)引起来，也可以不使用引号 * 值得取值类型： 1. 数字（整数或浮点数） 2. 字符串（在双引号中） 3. 逻辑值（true 或 false） 4. 数组（在方括号中） {\"persons\":[{},{}]} 5. 对象（在花括号中） {\"address\":{\"province\"：\"陕西\"....}} 6. null * 数据由逗号分隔：多个键值对由逗号分隔 * 花括号保存对象：使用{}定义json 格式 * 方括号保存数组：[] 2. 获取数据: 1. json对象.键名 2. json对象[\"键名\"] 3. 数组对象[索引] 4. 遍历 //1.定义基本格式 var person = {\"name\": \"张三\", age: 23, 'gender': true}; var ps = [{\"name\": \"张三\", \"age\": 23, \"gender\": true}, {\"name\": \"李四\", \"age\": 24, \"gender\": true}, {\"name\": \"王五\", \"age\": 25, \"gender\": false}]; ​​​​ //获取person对象中所有的键和值​ //for in 循环​ / for(var key in person){​ //这样的方式获取不行。因为相当于 person.”name”​ //alert(key + “:” + person.key);​ alert(key+”:”+person[key]);​ }/​ //获取ps中的所有值 for (var i = 0; i &lt; ps.length; i++) { var p = ps[i]; for(var key in p){ alert(key+”:”+p[key]); } } 3. JSON数据和Java对象的相互转换 * JSON解析器： * 常见的解析器：Jsonlib，Gson，fastjson，jackson 1. JSON转为Java对象 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. readValue(json字符串数据,Class) 2. Java对象转换JSON 1. 使用步骤： 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. 转换方法： * writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 * writeValueAsString(obj):将对象转为json字符串 2. 注解： 1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值得格式化 * @JsonFormat(pattern = \"yyyy-MM-dd\") 3. 复杂java对象转换 1. List：数组 2. Map：对象格式一致 案例：* 校验用户名是否存在 1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案： 1. $.get(type):将最后一个参数type指定为\"json\" 2. 在服务器端设置MIME类型 response.setContentType(\"application/json;charset=utf-8\"); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"13JQuery高级笔记","date":"2020-05-10T06:26:45.589Z","updated":"2020-05-10T06:24:01.715Z","comments":true,"path":"2020/05/10/13jquery-gao-ji-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/13jquery-gao-ji-bi-ji/","excerpt":"","text":"1234567891011121314151617title: JQuery 高级复习（十三）author: echodate: 2020-05-10 16:03:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - JavaWEB - 复习tags: - JavaWEB - 复习 [TOC] 今日内容：1. JQuery 高级 1. 动画 2. 遍历 3. 事件绑定 4. 案例 5. 插件 JQuery 高级1. 动画 1. 三种方式显示和隐藏元素 1. 默认显示和隐藏方式 1. show([speed,[easing],[fn]]) 1. 参数： 1. speed：动画的速度。三个预定义的值(\"slow\",\"normal\", \"fast\")或表示动画时长的毫秒数值(如：1000) 2. easing：用来指定切换效果，默认是\"swing\"，可用参数\"linear\" * swing：动画执行时效果是 先慢，中间快，最后又慢 * linear：动画执行时速度是匀速的 3. fn：在动画完成时执行的函数，每个元素执行一次。 2. hide([speed,[easing],[fn]]) 3. toggle([speed],[easing],[fn]) 2. 滑动显示和隐藏方式 1. slideDown([speed],[easing],[fn]) 2. slideUp([speed,[easing],[fn]]) 3. slideToggle([speed],[easing],[fn]) 3. 淡入淡出显示和隐藏方式 1. fadeIn([speed],[easing],[fn]) 2. fadeOut([speed],[easing],[fn]) 3. fadeToggle([speed,[easing],[fn]]) 2. 遍历 1. js的遍历方式 * for(初始化值;循环结束条件;步长) 2. jq的遍历方式 1. jq对象.each(callback) 1. 语法： jquery对象.each(function(index,element){}); * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象 2. 回调函数返回值： * true:如果当前function返回为false，则结束循环(break)。 * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) 2. $.each(object, [callback]) 3. for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 3. 事件绑定 1. jquery标准的绑定方式 * jq对象.事件方法(回调函数)； * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 * 表单对象.submit();//让表单提交 2. on绑定事件/off解除绑定 * jq对象.on(\"事件名称\",回调函数) * jq对象.off(\"事件名称\") * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 3. 事件切换：toggle * jq对象.toggle(fn1,fn2...) * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2..... * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 &lt;script src=\"../js/jquery-migrate-1.0.0.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; 4. 案例 1. 广告显示和隐藏 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt; &lt;style&gt; #content{width:100%;height:500px;background:#999} &lt;/style&gt; &lt;!--引入jquery--&gt; &lt;script type=\"text/javascript\" src=\"../js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; /* 需求： 1. 当页面加载完，3秒后。自动显示广告 2. 广告显示5秒后，自动消失。 分析： 1. 使用定时器来完成。setTimeout (执行一次定时器) 2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display 3. 使用 show/hide方法来完成广告的显示 */ //入口函数，在页面加载完成之后，定义定时器，调用这两个方法 $(function () { //定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); //定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); }); //显示广告 function adShow() { //获取广告div，调用显示方法 $(\"#ad\").show(\"slow\"); } //隐藏广告 function adHide() { //获取广告div，调用隐藏方法 $(\"#ad\").hide(\"slow\"); } ​​ L2Dwidget.init({\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false});!function(e){var c=Array.prototype.slice.call(document.querySelectorAll(\"img[data-original]\"));function i(){for(var r=0;r","categories":[],"tags":[]},{"title":"","slug":"12JQuery基础笔记","date":"2020-05-10T06:26:45.586Z","updated":"2020-05-10T06:23:23.806Z","comments":true,"path":"2020/05/10/12jquery-ji-chu-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/12jquery-ji-chu-bi-ji/","excerpt":"","text":"1234567891011121314151617title: JQuery 基础复习（十二）author: echodate: 2020-05-10 15:53:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - JavaWEB - 复习tags: - JavaWEB - 复习 [TOC] 今日内容1. JQuery 基础： 1. 概念 2. 快速入门 3. JQuery对象和JS对象区别与转换 4. 选择器 5. DOM操作 6. 案例 JQuery 基础：1. 概念： 一个JavaScript框架。简化JS开发 * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已 2. 快速入门 1. 步骤： 1. 下载JQuery * 目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日） * jquery-xxx.js 与 jquery-xxx.min.js区别： 1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些 2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 2. 导入JQuery的js文件：导入min.js文件 3. 使用 var div1 = $(\"#div1\"); alert(div1.html()); 3. JQuery对象和JS对象区别与转换 1. JQuery对象在操作时，更加方便。 2. JQuery对象和js对象方法不通用的. 3. 两者相互转换 * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引) * js -- &gt; jq : $(js对象) 4. 选择器：筛选具有相似特征的元素(标签) 1. 基本操作学习： 1. 事件绑定 //1.获取b1按钮 $(\"#b1\").click(function(){ alert(\"abc\"); }); 2. 入口函数 $(function () { }); window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 3. 样式控制：css方法 // $(\"#div1\").css(\"background-color\",\"red\"); $(\"#div1\").css(\"backgroundColor\",\"pink\"); 2. 分类 1. 基本选择器 1. 标签选择器（元素选择器） * 语法： $(\"html标签名\") 获得所有匹配标签名称的元素 2. id选择器 * 语法： $(\"#id的属性值\") 获得与指定id属性值匹配的元素 3. 类选择器 * 语法： $(\".class的属性值\") 获得与指定的class属性值匹配的元素 4. 并集选择器： * 语法： $(\"选择器1,选择器2....\") 获取多个选择器选中的所有元素 2. 层级选择器 1. 后代选择器 * 语法： $(\"A B \") 选择A元素内部的所有B元素 2. 子选择器 * 语法： $(\"A &gt; B\") 选择A元素内部的所有B子元素 3. 属性选择器 1. 属性名称选择器 * 语法： $(\"A[属性名]\") 包含指定属性的选择器 2. 属性选择器 * 语法： $(\"A[属性名='值']\") 包含指定属性等于指定值的选择器 3. 复合属性选择器 * 语法： $(\"A[属性名='值'][]...\") 包含多个属性条件的选择器 4. 过滤选择器 1. 首元素选择器 * 语法： :first 获得选择的元素中的第一个元素 2. 尾元素选择器 * 语法： :last 获得选择的元素中的最后一个元素 3. 非元素选择器 * 语法： :not(selector) 不包括指定内容的元素 4. 偶数选择器 * 语法： :even 偶数，从 0 开始计数 5. 奇数选择器 * 语法： :odd 奇数，从 0 开始计数 6. 等于索引选择器 * 语法： :eq(index) 指定索引元素 7. 大于索引选择器 * 语法： :gt(index) 大于指定索引元素 8. 小于索引选择器 * 语法： :lt(index) 小于指定索引元素 9. 标题选择器 * 语法： :header 获得标题（h1~h6）元素，固定写法 5. 表单过滤选择器 1. 可用元素选择器 * 语法： :enabled 获得可用元素 2. 不可用元素选择器 * 语法： :disabled 获得不可用元素 3. 选中选择器 * 语法： :checked 获得单选/复选框选中的元素 4. 选中选择器 * 语法： :selected 获得下拉框选中的元素 5. DOM操作 1. 内容操作 1. html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; 2. text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 3. val()： 获取/设置元素的value属性值 2. 属性操作 1. 通用属性操作 1. attr(): 获取/设置元素的属性 2. removeAttr():删除属性 3. prop():获取/设置元素的属性 4. removeProp():删除属性 * attr和prop区别？ 1. 如果操作的是元素的固有属性，则建议使用prop 2. 如果操作的是元素自定义的属性，则建议使用attr 2. 对class属性操作 1. addClass():添加class属性值 2. removeClass():删除class属性值 3. toggleClass():切换class属性 * toggleClass(\"one\"): * 判断如果元素对象上存在class=\"one\"，则将属性值one删除掉。 如果元素对象上不存在class=\"one\"，则添加 4. css(): 3. CRUD操作: 1. append():父元素将子元素追加到末尾 * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 2. prepend():父元素将子元素追加到开头 * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 3. appendTo(): * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 4. prependTo()： * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 5. after():添加元素到元素后边 * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 6. before():添加元素到元素前边 * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 7. insertAfter() * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 8. insertBefore() * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 9. remove():移除元素 * 对象.remove():将对象删除掉 10. empty():清空元素的所有后代元素。 * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点 6. 案例 ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"11Filter&Listener笔记","date":"2020-05-10T06:26:45.584Z","updated":"2020-05-10T06:22:35.305Z","comments":true,"path":"2020/05/10/11filter-listener-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/11filter-listener-bi-ji/","excerpt":"","text":"1234567891011121314151617title: Filter&amp;&amp;Listener复习（十一）author: echodate: 2020-05-10 15:43:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - JavaWEB - 复习tags: - JavaWEB - 复习 [TOC] 今日内容1. Filter：过滤器 2. Listener：监听器 Filter：过滤器1. 概念： * 生活中的过滤器：净水器,空气净化器，土匪、 * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 * 过滤器的作用： * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤... 2. 快速入门： 1. 步骤： 1. 定义一个类，实现接口Filter 2. 复写方法 3. 配置拦截路径 1. web.xml 2. 注解 2. 代码： @WebFilter(\"/*\")//访问所有资源之前，都会执行该过滤器 public class FilterDemo1 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"filterDemo1被执行了....\"); ​ //放行 filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } } 3. 过滤器细节： 1. web.xml配置 &lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 2. 过滤器执行流程 1. 执行过滤器 2. 执行放行后的资源 3. 回来执行过滤器放行代码下边的代码 3. 过滤器生命周期方法 1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 2. doFilter:每一次请求被拦截资源时，会执行。执行多次 3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 4. 过滤器配置详解 * 拦截路径配置： 1. 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 2. 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 3. 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 4. 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 * 拦截方式配置：资源被访问的方式 * 注解配置： * 设置dispatcherTypes属性 1. REQUEST：默认值。浏览器直接请求资源 2. FORWARD：转发访问资源 3. INCLUDE：包含访问资源 4. ERROR：错误跳转资源 5. ASYNC：异步访问资源 * web.xml配置 * 设置&lt;dispatcher&gt;&lt;/dispatcher&gt;标签即可 5. 过滤器链(配置多个过滤器) * 执行顺序：如果有两个过滤器：过滤器1和过滤器2 1. 过滤器1 2. 过滤器2 3. 资源执行 4. 过滤器2 5. 过滤器1 * 过滤器先后顺序问题： 1. 注解配置：按照类名的字符串比较规则比较，值小的先执行 * 如： AFilter 和 BFilter，AFilter就先执行了。 2. web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行 4. 案例： 1. 案例1_登录验证 * 需求： 1. 访问day17_case案例的资源。验证其是否登录 2. 如果登录了，则直接放行。 3. 如果没有登录，则跳转到登录页面，提示\"您尚未登录，请先登录\"。 ​ 2. 案例2_敏感词汇过滤 * 需求： 1. 对day17_case案例录入的数据进行敏感词汇过滤 2. 敏感词汇参考《敏感词汇.txt》 3. 如果是敏感词汇，替换为 *** * 分析： 1. 对request对象进行增强。增强获取参数相关方法 2. 放行。传递代理对象 * 增强对象的功能： * 设计模式：一些通用的解决固定问题的方式 1. 装饰模式 2. 代理模式 * 概念： 1. 真实对象：被代理的对象 2. 代理对象： 3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 * 实现方式： 1. 静态代理：有一个类文件描述代理模式 2. 动态代理：在内存中形成代理类 * 实现步骤： 1. 代理对象和真实对象实现相同的接口 2. 代理对象 = Proxy.newProxyInstance(); 3. 使用代理对象调用方法。 4. 增强方法 * 增强方式： 1. 增强参数列表 2. 增强返回值类型 3. 增强方法体执行逻辑 Listener：监听器* 概念：web的三大组件之一。 * 事件监听机制 * 事件 ：一件事情 * 事件源 ：事件发生的地方 * 监听器 ：一个对象 * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 * ServletContextListener:监听ServletContext对象的创建和销毁 * 方法： * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 * 步骤： 1. 定义一个类，实现ServletContextListener接口 2. 复写方法 3. 配置 1. web.xml &lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; * 指定初始化参数&lt;context-param&gt; 2. 注解： * @WebListener document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"10EL&JSTL笔记","date":"2020-05-10T06:26:45.581Z","updated":"2020-05-10T06:21:36.165Z","comments":true,"path":"2020/05/10/10el-jstl-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/10el-jstl-bi-ji/","excerpt":"","text":"1234567891011121314151617title: JSP&amp;&amp;EL&amp;&amp;JSTL复习（十）author: echodate: 2020-05-10 15:33:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - JavaWEB - 复习tags: - JavaWEB - 复习 [TOC] 今日内容1. JSP: 1. 指令 2. 注释 3. 内置对象 2. MVC开发模式 3. EL表达式 4. JSTL标签 5. 三层架构 JSP:1. 指令 * 作用：用于配置JSP页面，导入资源文件 * 格式： &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt; * 分类： 1. page ： 配置JSP页面的 * contentType：等同于response.setContentType() 1. 设置响应体的mime类型以及字符集 2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） * import：导包 * errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 * isErrorPage：标识当前也是是否是错误页面。 * true：是，可以使用内置对象exception * false：否。默认值。不可以使用内置对象exception 2. include ： 页面包含的。导入页面的资源文件 * &lt;%@include file=\"top.jsp\"%&gt; 3. taglib ： 导入资源 * &lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; * prefix：前缀，自定义的 2. 注释: 1. html注释： &lt;!-- --&gt;:只能注释html代码片段 2. jsp注释：推荐使用 &lt;%-- --%&gt;：可以注释所有 3. 内置对象 * 在jsp页面中不需要创建，直接使用的对象 * 一共有9个： 变量名 真实类型 作用 * pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 * request HttpServletRequest 一次请求访问的多个资源(转发) * session HttpSession 一次会话的多个请求间 * application ServletContext 所有用户间共享数据 * response HttpServletResponse 响应对象 * page Object 当前页面(Servlet)的对象 this * out JspWriter 输出对象，数据输出到页面上 * config ServletConfig Servlet的配置对象 * exception Throwable 异常对象 ​ MVC：开发模式1. jsp演变历史 1. 早期只有servlet，只能使用response输出标签数据，非常麻烦 2. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 2. MVC： 1. M：Model，模型。JavaBean * 完成具体的业务操作，如：查询数据库，封装对象 2. V：View，视图。JSP * 展示数据 3. C：Controller，控制器。Servlet * 获取用户的输入 * 调用模型 * 将数据交给视图进行展示 * 优缺点： 1. 优点： 1. 耦合性低，方便维护，可以利于分工协作 2. 重用性高 2. 缺点： 1. 使得项目架构变得复杂，对开发人员要求高 EL表达式1. 概念：Expression Language 表达式语言 2. 作用：替换和简化jsp页面中java代码的编写 3. 语法：${表达式} 4. 注意： * jsp默认支持el表达式的。如果要忽略el表达式 1. 设置jsp中page指令中：isELIgnored=\"true\" 忽略当前jsp页面中所有的el表达式 2. \\${表达式} ：忽略当前这个el表达式 5. 使用： 1. 运算： * 运算符： 1. 算数运算符： + - * /(div) %(mod) 2. 比较运算符： &gt; &lt; &gt;= &lt;= == != 3. 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 4. 空运算符： empty * 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 * ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0 * ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0 2. 获取值 1. el表达式只能从域对象中获取值 2. 语法： 1. ${域名称.键名}：从指定域中获取指定键的值 * 域名称： 1. pageScope --&gt; pageContext 2. requestScope --&gt; request 3. sessionScope --&gt; session 4. applicationScope --&gt; application（ServletContext） * 举例：在request域中存储了name=张三 * 获取：${requestScope.name} 2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 ​​ 3. 获取对象、List集合、Map集合的值 1. 对象：${域名称.键名.属性名} * 本质上会去调用对象的getter方法 2. List集合：${域名称.键名[索引]} 3. Map集合： * ${域名称.键名.key名称} * ${域名称.键名[\"key名称\"]} 3. 隐式对象： * el表达式中有11个隐式对象 * pageContext： * 获取jsp其他八个内置对象 * ${pageContext.request.contextPath}：动态获取虚拟目录 ​ JSTL1. 概念：JavaServer Pages Tag Library JSP标准标签库 * 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt; 2. 作用：用于简化和替换jsp页面上的java代码 3. 使用步骤： 1. 导入jstl相关jar包 2. 引入标签库：taglib指令： &lt;%@ taglib %&gt; 3. 使用标签 4. 常用的JSTL标签 1. if:相当于java代码的if语句 1. 属性： * test 必须属性，接受boolean表达式 * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 * 一般情况下，test属性值会结合el表达式一起使用 2. 注意： * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 2. choose:相当于java代码的switch语句 1. 使用choose标签声明 相当于switch声明 2. 使用when标签做判断 相当于case 3. 使用otherwise标签做其他情况的声明 相当于default 3. foreach:相当于java代码的for语句 5. 练习： * 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中 三层架构：软件设计架构1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互 2. 业务逻辑层：处理业务逻辑的。 3. 数据访问层：操作数据存储文件。 案例：用户信息列表展示1. 需求：用户信息的增删改查操作 2. 设计： 1. 技术选型：Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat 2. 数据库设计： create database day17; -- 创建数据库 use day17; -- 使用数据库 create table user( -- 创建表 id int primary key auto_increment, name varchar(20) not null, gender varchar(5), age int, address varchar(32), qq varchar(20), email varchar(50) ); 3. 开发： 1. 环境搭建 1. 创建数据库环境 2. 创建项目，导入需要的jar包 2. 编码 4. 测试 5. 部署运维 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"09Cookie&Session笔记","date":"2020-05-10T06:26:45.578Z","updated":"2020-05-10T06:19:58.388Z","comments":true,"path":"2020/05/10/09cookie-session-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/09cookie-session-bi-ji/","excerpt":"","text":"1234567891011121314151617title: 会话技术&amp;&amp;JSP复习（九）author: echodate: 2020-05-10 15:23:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - JavaWEB - 复习tags: - JavaWEB - 复习 [TOC] 今日内容1. 会话技术 1. Cookie 2. Session 2. JSP：入门学习 会话技术1. 会话：一次会话中包含多次请求和响应。 * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 2. 功能：在一次会话的范围内的多次请求间，共享数据 3. 方式： 1. 客户端会话技术：Cookie 2. 服务器端会话技术：Session Cookie：1. 概念：客户端会话技术，将数据保存到客户端 2. 快速入门： * 使用步骤： 1. 创建Cookie对象，绑定数据 * new Cookie(String name, String value) 2. 发送Cookie对象 * response.addCookie(Cookie cookie) 3. 获取Cookie，拿到数据 * Cookie[] request.getCookies() 3. 实现原理 * 基于响应头set-cookie和请求头cookie实现 4. cookie的细节 1. 一次可不可以发送多个cookie? * 可以 * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 2. cookie在浏览器中保存多长时间？ 1. 默认情况下，当浏览器关闭后，Cookie数据被销毁 2. 持久化存储： * setMaxAge(int seconds) 1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 2. 负数：默认值 3. 零：删除cookie信息 3. cookie能不能存中文？ * 在tomcat 8 之前 cookie中不能直接存储中文数据。 * 需要将中文数据转码---一般采用URL编码(%E3) String name = URLEncoder.encode(\"姓名\", \"UTF-8\"); URLDecoder.decode(c.getValue(), \"UTF-8\"); * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 4. cookie共享问题？ 1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ * 默认情况下cookie不能共享 * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 * 如果要共享，则可以将path设置为\"/\" ​​ 2. 不同的tomcat服务器间cookie共享问题？​ setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享​ setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享 5. Cookie的特点和作用 1. cookie存储数据在客户端浏览器 2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) * 作用： 1. cookie一般用于存出少量的不太敏感的数据 2. 在不登录的情况下，完成服务器对客户端的身份识别 6. 案例：记住上一次访问时间 1. 需求： 1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 2. 分析： 1. 可以采用Cookie来完成 2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie 1. 有：不是第一次访问 1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20 2. 写回Cookie：lastTime=2018年6月10日11:50:01 2. 没有：是第一次访问 1. 响应数据：您好，欢迎您首次访问 2. 写回Cookie：lastTime=2018年6月10日11:50:01 3. 代码实现： package cn.itcast.cookie; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.Cookie; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.net.URLDecoder; import java.net.URLEncoder; import java.text.SimpleDateFormat; import java.util.Date; @WebServlet(\"/cookieTest\") public class CookieTest extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置响应的消息体的数据格式以及编码 response.setContentType(\"text/html;charset=utf-8\"); //1.获取所有Cookie Cookie[] cookies = request.getCookies(); boolean flag = false;//没有cookie为lastTime //2.遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0){ for (Cookie cookie : cookies) { //3.获取cookie的名称 String name = cookie.getName(); //4.判断名称是否是：lastTime if(\"lastTime\".equals(name)){ //有该Cookie，不是第一次访问 flag = true;//有lastTime的cookie //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String str_date = sdf.format(date); System.out.println(\"编码前：\"+str_date); //URL编码 str_date = URLEncoder.encode(str_date,\"utf-8\"); System.out.println(\"编码后：\"+str_date); cookie.setValue(str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); ​​ //响应数据​ //获取Cookie的value，时间​ String value = cookie.getValue();​ System.out.println(“解码前：”+value);​ //URL解码：​ value = URLDecoder.decode(value,”utf-8”);​ System.out.println(“解码后：”+value);​ response.getWriter().write(“欢迎回来，您上次访问时间为:”+value+”“);​ break; } } } ​​ if(cookies == null || cookies.length == 0 || flag == false){​ //没有，第一次访问​ //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(“yyyy年MM月dd日 HH:mm:ss”); String str_date = sdf.format(date); System.out.println(“编码前：”+str_date); //URL编码 str_date = URLEncoder.encode(str_date,”utf-8”); System.out.println(“编码后：”+str_date); Cookie cookie = new Cookie(\"lastTime\",str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); response.getWriter().write(\"&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;\"); } ​​ }​ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } } JSP：入门学习1. 概念： * Java Server Pages： java服务器端页面 * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 * 用于简化书写！！！ 2. 原理 * JSP本质上就是一个Servlet 3. JSP的脚本：JSP定义Java代码的方式 1. &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 2. &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。 3. &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 4. JSP的内置对象： * 在jsp页面中不需要获取和创建，可以直接使用的对象 * jsp一共有9个内置对象。 * 今天学习3个： * request * response * out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 * response.getWriter()和out.write()的区别： * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 * response.getWriter()数据输出永远在out.write()之前 5. 案例:改造Cookie案例 Session：主菜1. 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 2. 快速入门： 1. 获取HttpSession对象： HttpSession session = request.getSession(); 2. 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 3. 原理 * Session的实现是依赖于Cookie的。 ​​ 4. 细节：​ 1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？​ 默认情况下。不是。​ 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。​ Cookie c = new Cookie(“JSESSIONID”,session.getId());​ c.setMaxAge(60*60);​ response.addCookie(c);​ 2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 * session的钝化： * 在服务器正常关闭之前，将session对象系列化到硬盘上 * session的活化： * 在服务器启动后，将session文件转化为内存中的session对象即可。 3. session什么时候被销毁？ 1. 服务器关闭 2. session对象调用invalidate() 。 3. session默认失效时间 30分钟 选择性配置修改 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; 5. session的特点 1. session用于存储一次会话的多次请求的数据，存在服务器端 2. session可以存储任意类型，任意大小的数据 * session与Cookie的区别： 1. session存储数据在服务器端，Cookie在客户端 2. session没有数据大小限制，Cookie有 3. session数据安全，Cookie相对于不安全 案例：验证码1. 案例需求： 1. 访问带有验证码的登录页面login.jsp 2. 用户输入用户名，密码以及验证码。 * 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 * 如果验证码输入有误，跳转登录页面，提示：验证码错误 * 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 2. 分析： ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"08Response笔记","date":"2020-05-10T06:26:45.575Z","updated":"2020-05-10T06:18:28.502Z","comments":true,"path":"2020/05/10/08response-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/08response-bi-ji/","excerpt":"","text":"1234567891011121314151617title: Response对象&amp;&amp;ServletContext对象复习（八）author: echodate: 2020-05-10 15:13:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - JavaWEB - 复习tags: - JavaWEB - 复习 [TOC] 今日内容1. HTTP协议：响应消息 2. Response对象 3. ServletContext对象 HTTP协议：1. 请求消息：客户端发送给服务器端的数据 * 数据格式： 1. 请求行 2. 请求头 3. 请求空行 4. 请求体 2. 响应消息：服务器端发送给客户端的数据 * 数据格式： 1. 响应行 1. 组成：协议/版本 响应状态码 状态码描述 2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 1. 状态码都是3位数字 2. 分类： 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误。 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常) ​ 2. 响应头： 1. 格式：头名称： 值 2. 常见的响应头： 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据 * 值： * in-line:默认值,在当前页面内打开 * attachment;filename=xxx：以附件形式打开响应体。文件下载 3. 响应空行 4. 响应体:传输的数据 * 响应字符串格式 HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; Response对象* 功能：设置响应消息 1. 设置响应行 1. 格式：HTTP/1.1 200 ok 2. 设置状态码：setStatus(int sc) 2. 设置响应头：setHeader(String name, String value) 3. 设置响应体： * 使用步骤： 1. 获取输出流 * 字符输出流：PrintWriter getWriter() * 字节输出流：ServletOutputStream getOutputStream() 2. 使用输出流，将数据输出到客户端浏览器 * 案例： 1. 完成重定向 * 重定向：资源跳转的方式 * 代码实现： //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(\"location\",\"/day15/responseDemo2\"); //简单的重定向方法 response.sendRedirect(\"/day15/responseDemo2\"); * 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据 * 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据 * forward 和 redirect 区别 * 路径写法： 1. 路径分类 1. 相对路径：通过相对路径不可以确定唯一资源 * 如：./index.html * 不以/开头，以.开头路径 * 规则：找到当前资源和目标资源之间的相对位置关系 * ./：当前目录 * ../:后退一级目录 2. 绝对路径：通过绝对路径可以确定唯一资源 * 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 * 以/开头的路径 * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) * 建议虚拟目录动态获取：request.getContextPath() * &lt;a&gt; , &lt;form&gt; 重定向... * 给服务器使用：不需要加虚拟目录 * 转发路径 ​​ 2. 服务器输出字符数据到浏览器 * 步骤： 1. 获取字符输出流 2. 输出数据 * 注意： * 乱码问题： 1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 //简单的形式，设置编码，是在获取流之前设置 response.setContentType(\"text/html;charset=utf-8\"); 3. 服务器输出字节数据到浏览器 * 步骤： 1. 获取字节输出流 2. 输出数据 4. 验证码 1. 本质：图片 2. 目的：防止恶意表单注册 ServletContext对象：1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信 2. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext(); 3. 功能： 1. 获取MIME类型： * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) 2. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据 3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) String b = context.getRealPath(\"/b.txt\");//web目录下资源访问 System.out.println(b); String c = context.getRealPath(\"/WEB-INF/c.txt\");//WEB-INF目录下的资源访问 System.out.println(c); String a = context.getRealPath(\"/WEB-INF/classes/a.txt\");//src目录下的资源访问 System.out.println(a); 案例：* 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载 * 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： * content-disposition:attachment;filename=xxx * 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename=xxx 4. 将数据写出到response输出流 * 问题： * 中文文件问题 * 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"07Servlet&HTTP&Request笔记","date":"2020-05-10T06:26:45.572Z","updated":"2020-05-10T06:17:05.763Z","comments":true,"path":"2020/05/10/07servlet-http-request-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/07servlet-http-request-bi-ji/","excerpt":"","text":"1234567891011121314151617title: Servlet&amp;&amp;HTTP&amp;&amp;Request复习（七）author: echodate: 2020-05-10 15:03:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - JavaWEB - 复习tags: - JavaWEB - 复习 [TOC] 今日内容：1. Servlet 2. HTTP协议 3. Request Servlet：1. 概念 2. 步骤 3. 执行原理 4. 生命周期 5. Servlet3.0 注解配置 6. Servlet的体系结构 Servlet -- 接口 | GenericServlet -- 抽象类 | HttpServlet -- 抽象类 * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 * HttpServlet：对http协议的一种封装，简化操作 1. 定义类继承HttpServlet 2. 复写doGet/doPost方法 7. Servlet相关配置 1. urlpartten:Servlet访问路径 1. 一个Servlet可以定义多个访问路径 ： @WebServlet({\"/d4\",\"/dd4\",\"/ddd4\"}) 2. 路径定义规则： 1. /xxx：路径匹配 2. /xxx/xxx:多层路径，目录结构 3. *.do：扩展名匹配 HTTP：* 概念：Hyper Text Transfer Protocol 超文本传输协议 * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 * 特点： 1. 基于TCP/IP的高级协议 2. 默认端口号:80 3. 基于请求/响应模型的:一次请求对应一次响应 4. 无状态的：每次请求之间相互独立，不能交互数据 * 历史版本： * 1.0：每一次请求响应都会建立新的连接 * 1.1：复用连接 * 请求消息数据格式 1. 请求行 请求方式 请求url 请求协议/版本 GET /login.html HTTP/1.1 * 请求方式： * HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 * 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http://localhost/login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作： 3. 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 4. 请求体(正文)： * 封装POST请求消息的请求参数的 * 字符串格式： POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan * 响应消息数据格式 Request：1. request对象和response对象的原理 1. request和response对象是由服务器创建的。我们来使用它们 2. request对象是来获取请求消息，response对象是来设置响应消息 2. request对象继承体系结构： ServletRequest -- 接口 | 继承 HttpServletRequest -- 接口 | 实现 org.apache.catalina.connector.RequestFacade 类(tomcat) 3. request功能： 1. 获取请求消息数据 1. 获取请求行数据 * GET /day14/demo1?name=zhangsan HTTP/1.1 * 方法： 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/day14 * String getContextPath() 3. 获取Servlet路径: /demo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/day14/demo1 * String getRequestURI(): /day14/demo1 * StringBuffer getRequestURL() :http://localhost/day14/demo1 * URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国 * URI：统一资源标识符 : /day14/demo1 共和国 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr() 2. 获取请求头数据 * 方法： * (*)String getHeader(String name):通过请求头的名称获取请求头的值 * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称 3. 获取请求体数据: * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 * 步骤： 1. 获取流对象 * BufferedReader getReader()：获取字符输入流，只能操作字符数据 * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 * 在文件上传知识点后讲解 2. 再从流对象中拿数据 ​ 2. 其他功能： 1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game 3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称 4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 * 中文乱码问题： * get方式：tomcat 8 已经将get方式乱码问题解决了 * post方式：会乱码 * 解决：在获取参数前，设置request的编码request.setCharacterEncoding(\"utf-8\"); ​ 2. 请求转发：一种在服务器内部的资源跳转方式 1. 步骤： 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 2. 特点： 1. 浏览器地址栏路径不发生变化 2. 只能转发到当前服务器内部资源中。 3. 转发是一次请求 3. 共享数据： * 域对象：一个有作用范围的对象，可以在范围内共享数据 * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 * 方法： 1. void setAttribute(String name,Object obj):存储数据 2. Object getAttitude(String name):通过键获取值 3. void removeAttribute(String name):通过键移除键值对 4. 获取ServletContext： * ServletContext getServletContext() 案例：用户登录* 用户登录案例需求： 1.编写login.html登录页面 username &amp; password 两个输入框 2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表 3.使用JdbcTemplate技术封装JDBC 4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 * 分析 * 开发步骤 1. 创建项目，导入html页面，配置文件，jar包 2. 创建数据库环境 CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 3. 创建包cn.itcast.domain,创建类User package cn.itcast.domain; /** * 用户的实体类 */ public class User { private int id; private String username; private String password; ​ public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '}'; } } 4. 创建包cn.itcast.util,编写工具类JDBCUtils package cn.itcast.util; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import javax.xml.crypto.Data; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * JDBC工具类 使用Durid连接池 */ public class JDBCUtils { private static DataSource ds ; static { try { //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接池对象 */ public static DataSource getDataSource(){ return ds; } ​ /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } } 5. 创建包cn.itcast.dao,创建类UserDao,提供login方法 package cn.itcast.dao; import cn.itcast.domain.User; import cn.itcast.util.JDBCUtils; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表的类 */ public class UserDao { //声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user包含用户全部数据,没有查询到，返回null */ public User login(User loginUser){ try { //1.编写sql String sql = \"select * from user where username = ? and password = ?\"; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); ​ return user; } catch (DataAccessException e) { e.printStackTrace();//记录日志 return null; } } } 6. 编写cn.itcast.web.servlet.LoginServlet类 package cn.itcast.web.servlet; import cn.itcast.dao.UserDao; import cn.itcast.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; ​ @WebServlet(“/loginServlet”) public class LoginServlet extends HttpServlet { ​ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.设置编码 req.setCharacterEncoding(“utf-8”); //2.获取请求参数 String username = req.getParameter(“username”); String password = req.getParameter(“password”); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null){ //登录失败 req.getRequestDispatcher(\"/failServlet\").forward(req,resp); }else{ //登录成功 //存储数据 req.setAttribute(\"user\",user); //转发 req.getRequestDispatcher(\"/successServlet\").forward(req,resp); } } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } 7. 编写FailServlet和SuccessServlet类 @WebServlet(\"/successServlet\") public class SuccessServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //获取request域中共享的user对象 User user = (User) request.getAttribute(\"user\"); if(user != null){ //给页面写一句话 //设置编码 response.setContentType(\"text/html;charset=utf-8\"); //输出 response.getWriter().write(\"登录成功！\"+user.getUsername()+\",欢迎您\"); } ​ } @WebServlet(\"/failServlet\") public class FailServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //给页面写一句话 //设置编码 response.setContentType(\"text/html;charset=utf-8\"); //输出 response.getWriter().write(\"登录失败，用户名或密码错误\"); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request,response); } } 8. login.html中form表单的action路径的写法 * 虚拟目录+Servlet的资源路径 9. BeanUtils工具类，简化数据封装 * 用于封装JavaBean的 1. JavaBean：标准的Java类 1. 要求： 1. 类必须被public修饰 2. 必须提供空参的构造器 3. 成员变量必须使用private修饰 4. 提供公共setter和getter方法 2. 功能：封装数据 2. 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() --&gt; Username--&gt; username 3. 方法： 1. setProperty() 2. getProperty() 3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"06Tomcat&Servlet笔记","date":"2020-05-10T06:26:45.541Z","updated":"2020-05-10T06:15:02.595Z","comments":true,"path":"2020/05/10/06tomcat-servlet-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/06tomcat-servlet-bi-ji/","excerpt":"","text":"12345678910111213141516171819title: Tomcat&amp;&amp;Servlet复习（六）author: echodate: 2020-05-10 14:53:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - JavaWEB - Tomcat - 复习tags: - JavaWEB - Tomcat - 复习 [TOC] 今日内容1. web相关概念回顾 2. web服务器软件：Tomcat 3. Servlet入门学习 web相关概念回顾1. 软件架构 1. C/S：客户端/服务器端 2. B/S：浏览器/服务器端 2. 资源分类 1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析 * 如： html,css,JavaScript 2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器 * 如：servlet/jsp,php,asp.... 3. 网络通信三要素 1. IP：电子设备(计算机)在网络中的唯一标识。 2. 端口：应用程序在计算机中的唯一标识。 0~65536 3. 传输协议：规定了数据传输的规则 1. 基础协议： 1. tcp:安全协议，三次握手。 速度稍慢 2. udp：不安全协议。 速度快 web服务器软件：* 服务器：安装了服务器软件的计算机 * 服务器软件：接收用户的请求，处理请求，做出响应 * web服务器软件：接收用户的请求，处理请求，做出响应。 * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 * web容器 * 常见的java相关的web服务器软件： * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 * Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。 * JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 * Tomcat：web服务器软件 1. 下载：http://tomcat.apache.org/ 2. 安装：解压压缩包即可。 * 注意：安装目录建议不要有中文和空格 3. 卸载：删除目录就行了 4. 启动： * bin/startup.bat ,双击运行该文件即可 * 访问：浏览器输入：http://localhost:8080 回车访问自己 http://别人的ip:8080 访问别人 * 可能遇到的问题： 1. 黑窗口一闪而过： * 原因： 没有正确配置JAVA_HOME环境变量 * 解决方案：正确配置JAVA_HOME环境变量 2. 启动报错： 1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程 * netstat -ano 2. 温柔：修改自身的端口号 * conf/server.xml * &lt;Connector port=\"8888\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8445\" /&gt; * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 * 好处：在访问时，就不用输入端口号 5. 关闭： 1. 正常关闭： * bin/shutdown.bat * ctrl+c 2. 强制关闭： * 点击启动窗口的× 6. 配置: * 部署项目的方式： 1. 直接将项目放到webapps目录下即可。 * /hello：项目的访问路径--&gt;虚拟目录 * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 * war包会自动解压缩 2. 配置conf/server.xml文件 在&lt;Host&gt;标签体中配置 &lt;Context docBase=\"D:\\hello\" path=\"/hehe\" /&gt; * docBase:项目存放的路径 * path：虚拟目录 3. 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写 &lt;Context docBase=\"D:\\hello\" /&gt; * 虚拟目录：xml文件的名称 * 静态项目和动态项目： * 目录结构 * java动态项目的目录结构： -- 项目的根目录 -- WEB-INF目录： -- web.xml：web项目的核心配置文件 -- classes目录：放置字节码文件的目录 -- lib目录：放置依赖的jar包 * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。 Servlet： server applet* 概念：运行在服务器端的小程序 * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 * 将来我们自定义一个类，实现Servlet接口，复写方法。 * 快速入门： 1. 创建JavaEE项目 2. 定义一个类，实现Servlet接口 * public class ServletDemo1 implements Servlet 3. 实现接口中的抽象方法 4. 配置Servlet 在web.xml中配置： &lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; * 执行原理： 1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 3. 如果有，则在找到对应的&lt;servlet-class&gt;全类名 4. tomcat会将字节码文件加载进内存，并且创建其对象 5. 调用其方法 * Servlet中的生命周期方法： 1. 被创建：执行init方法，只执行一次 * Servlet什么时候被创建？ * 默认情况下，第一次被访问时，Servlet被创建 * 可以配置执行Servlet的创建时机。 * 在&lt;servlet&gt;标签下配置 1. 第一次被访问时，创建 * &lt;load-on-startup&gt;的值为负数 2. 在服务器启动时，创建 * &lt;load-on-startup&gt;的值为0或正整数 * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 * 多个用户同时访问时，可能存在线程安全问题。 * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 2. 提供服务：执行service方法，执行多次 * 每次访问Servlet时，Service方法都会被调用一次。 3. 被销毁：执行destroy方法，只执行一次 * Servlet被销毁时执行。服务器关闭时，Servlet被销毁 * 只有服务器正常关闭时，才会执行destroy方法。 * destroy方法在Servlet被销毁之前执行，一般用于释放资源 * Servlet3.0： * 好处： * 支持注解配置。可以不需要web.xml了。 * 步骤： 1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 2. 定义一个类，实现Servlet接口 3. 复写方法 4. 在类上使用@WebServlet注解，进行配置 * @WebServlet(\"资源路径\") @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet { String name() default \"\";//相当于&lt;Servlet-name&gt; String[] value() default {};//代表urlPatterns()属性配置 String[] urlPatterns() default {};//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default {}; boolean asyncSupported() default false; String smallIcon() default \"\"; String largeIcon() default \"\"; String description() default \"\"; String displayName() default \"\"; } IDEA与tomcat的相关配置1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件 * 查看控制台的log：Using CATALINA_BASE: \"C:\\Users\\fqy\\.IntelliJIdea2018.1\\system\\tomcat\\_itcast\" 2. 工作空间项目 和 tomcat部署的web项目 * tomcat真正访问的是“tomcat部署的web项目”，\"tomcat部署的web项目\"对应着\"工作空间项目\" 的web目录下的所有资源 * WEB-INF目录下的资源不能被浏览器直接访问。 3. 断点调试：使用\"小虫子\"启动 dubug 启动 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"05xml笔记","date":"2020-05-10T06:26:45.539Z","updated":"2020-05-10T06:12:26.862Z","comments":true,"path":"2020/05/10/05xml-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/05xml-bi-ji/","excerpt":"","text":"title: XML复习（五）author: echodate: 2020-05-10 14:43:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - XML - 复习 tags: - XML - 复习 [TOC] 今日内容1. XML 1. 概念 2. 语法 3. 解析 XML：1. 概念：Extensible Markup Language 可扩展标记语言 * 可扩展：标签都是自定义的。 &lt;user&gt; &lt;student&gt; * 功能 * 存储数据 1. 配置文件 2. 在网络中传输 * xml与html的区别 1. xml标签都是自定义的，html标签是预定义。 2. xml的语法严格，html语法松散 3. xml是存储数据的，html是展示数据 * w3c:万维网联盟 2. 语法： * 基本语法： 1. xml文档的后缀名 .xml 2. xml第一行必须定义为文档声明 3. xml文档中有且仅有一个根标签 4. 属性值必须使用引号(单双都可)引起来 5. 标签必须正确关闭 6. xml标签名称区分大小写 * 快速入门： &lt;?xml version='1.0' ?&gt; &lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt; &lt;/users&gt; * 组成部分： 1. 文档声明 1. 格式：&lt;?xml 属性列表 ?&gt; 2. 属性列表： * version：版本号，必须的属性 * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 * standalone：是否独立 * 取值： * yes：不依赖其他文件 * no：依赖其他文件 2. 指令(了解)：结合css的 * &lt;?xml-stylesheet type=\"text/css\" href=\"a.css\" ?&gt; 3. 标签：标签名称自定义的 * 规则： * 名称可以包含字母、数字以及其他的字符 * 名称不能以数字或者标点符号开始 * 名称不能以字母 xml（或者 XML、Xml 等等）开始 * 名称不能包含空格 4. 属性： id属性值唯一 5. 文本： * CDATA区：在该区域中的数据会被原样展示 * 格式： &lt;![CDATA[ 数据 ]]&gt; ​ * 约束：规定xml文档的书写规则 * 作为框架的使用者(程序员)： 1. 能够在xml中引入约束文档 2. 能够简单的读懂约束文档 * 分类： 1. DTD:一种简单的约束技术 2. Schema:一种复杂的约束技术 * DTD： * 引入dtd文档到xml文档中 * 内部dtd：将约束规则定义在xml文档中 * 外部dtd：将约束的规则定义在外部的dtd文件中 * 本地：&lt;!DOCTYPE 根标签名 SYSTEM \"dtd文件的位置\"&gt; * 网络：&lt;!DOCTYPE 根标签名 PUBLIC \"dtd文件名字\" \"dtd文件的位置URL\"&gt; * Schema: * 引入： 1.填写xml文档的根元素 2.引入xsi前缀. xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" 3.引入xsd文件命名空间. xsi:schemaLocation=\"http://www.itcast.cn/xml student.xsd\" 4.为每一个xsd约束声明一个前缀,作为标识 xmlns=\"http://www.itcast.cn/xml\" &lt;students xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.itcast.cn/xml\" xsi:schemaLocation=\"http://www.itcast.cn/xml student.xsd\"&gt; ​ 3. 解析：操作xml文档，将文档中的数据读取到内存中 * 操作xml文档 1. 解析(读取)：将文档中的数据读取到内存中 2. 写入：将内存中的数据保存到xml文档中。持久化的存储 * 解析xml的方式： 1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 * 优点：操作方便，可以对文档进行CRUD的所有操作 * 缺点：占内存 2. SAX：逐行读取，基于事件驱动的。 * 优点：不占内存。 * 缺点：只能读取，不能增删改 ​ * xml常见的解析器： 1. JAXP：sun公司提供的解析器，支持dom和sax两种思想 2. DOM4J：一款非常优秀的解析器 3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 4. PULL：Android操作系统内置的解析器，sax方式的。 * Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 * 快速入门： * 步骤： 1. 导入jar包 2. 获取Document对象 3. 获取对应的标签Element对象 4. 获取数据 * 代码： //2.1获取student.xml的path String path = JsoupDemo1.class.getClassLoader().getResource(\"student.xml\").getPath(); //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document Document document = Jsoup.parse(new File(path), \"utf-8\"); //3.获取元素对象 Element Elements elements = document.getElementsByTag(\"name\"); System.out.println(elements.size()); //3.1获取第一个name的Element对象 Element element = elements.get(0); //3.2获取数据 String name = element.text(); System.out.println(name); * 对象的使用： 1. Jsoup：工具类，可以解析html或xml文档，返回Document * parse：解析html或xml文档，返回Document * parse​(File in, String charsetName)：解析xml或html文件的。 * parse​(String html)：解析xml或html字符串 * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2. Document：文档对象。代表内存中的dom树 * 获取Element对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用 4. Element：元素对象 1. 获取子元素对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 2. 获取属性值 * String attr(String key)：根据属性名称获取属性值 3. 获取文本内容 * String text():获取文本内容 * String html():获取标签体的所有内容(包括字标签的字符串内容) 5. Node：节点对象 * 是Document和Element的父类 ​ * 快捷查询方式： 1. selector:选择器 * 使用的方法：Elements select​(String cssQuery) * 语法：参考Selector类中定义的语法 2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 * 使用Jsoup的Xpath需要额外导入jar包。 * 查询w3cshool参考手册，使用xpath的语法完成查询 * 代码： //1.获取student.xml的path String path = JsoupDemo6.class.getClassLoader().getResource(\"student.xml\").getPath(); //2.获取Document对象 Document document = Jsoup.parse(new File(path), \"utf-8\"); //3.根据document对象，创建JXDocument对象 JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询 //4.1查询所有student标签 List&lt;JXNode&gt; jxNodes = jxDocument.selN(\"//student\"); for (JXNode jxNode : jxNodes) { System.out.println(jxNode); } System.out.println(\"--------------------\"); //4.2查询所有student标签下的name标签 List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(\"//student/name\"); for (JXNode jxNode : jxNodes2) { System.out.println(jxNode); } System.out.println(\"--------------------\"); //4.3查询student标签下带有id属性的name标签 List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(\"//student/name[@id]\"); for (JXNode jxNode : jxNodes3) { System.out.println(jxNode); } System.out.println(\"--------------------\"); //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(\"//student/name[@id='itcast']\"); for (JXNode jxNode : jxNodes4) { System.out.println(jxNode); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"04JavaScript高级笔记","date":"2020-05-10T06:26:45.537Z","updated":"2020-05-10T06:11:20.397Z","comments":true,"path":"2020/05/10/04javascript-gao-ji-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/04javascript-gao-ji-bi-ji/","excerpt":"","text":"12345678910111213141516171819title: JavaScript复习（四）author: echodate: 2020-05-10 14:33:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - JavaScript - DOM - 复习tags: - JavaScript - DOM - 复习 [TOC] 今日内容：1. JavaScript： 1. ECMAScript： 2. BOM： 3. DOM： 1. 事件 DOM简单学习：为了满足案例要求* 功能：控制html文档的内容 * 获取页面标签(元素)对象：Element * document.getElementById(\"id值\"):通过元素的id获取元素对象 * 操作Element对象： 1. 修改属性值： 1. 明确获取的对象是哪一个？ 2. 查看API文档，找其中有哪些属性可以设置 2. 修改标签体内容： * 属性：innerHTML 1. 获取元素对象 2. 使用innerHTML属性修改标签体内容 事件简单学习* 功能： 某些组件被执行了某些操作后，触发某些代码的执行。 * 造句： xxx被xxx,我就xxx * 我方水晶被摧毁后，我就责备对友。 * 敌方水晶被摧毁后，我就夸奖自己。 * 如何绑定事件 1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码 1. 事件：onclick--- 单击事件 2. 通过js获取元素对象，指定事件属性，设置一个函数 * 代码： &lt;body&gt; &lt;img id=\"light\" src=\"img/off.gif\" onclick=\"fun();\"&gt; &lt;img id=\"light2\" src=\"img/off.gif\"&gt; &lt;script&gt; function fun(){ alert('我被点了'); alert('我又被点了'); } function fun2(){ alert('咋老点我？'); } //1.获取light2对象 var light2 = document.getElementById(\"light2\"); //2.绑定事件 light2.onclick = fun2; ​ * 案例1：电灯开关 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;电灯开关&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=\"light\" src=\"img/off.gif\"&gt; &lt;script&gt; /* 分析： 1.获取图片对象 2.绑定单击事件 3.每次点击切换图片 * 规则： * 如果灯是开的 on,切换图片为 off * 如果灯是关的 off,切换图片为 on * 使用标记flag来完成 */ //1.获取图片对象 var light = document.getElementById(\"light\"); var flag = false;//代表灯是灭的。 off图片 //2.绑定单击事件 light.onclick = function(){ if(flag){//判断如果灯是开的，则灭掉 light.src = \"img/off.gif\"; flag = false; }else{ //如果灯是灭的，则打开 light.src = \"img/on.gif\"; flag = true; } ​ } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; BOM:1. 概念：Browser Object Model 浏览器对象模型 * 将浏览器的各个组成部分封装成对象。 2. 组成： * Window：窗口对象 * Navigator：浏览器对象 * Screen：显示器屏幕对象 * History：历史记录对象 * Location：地址栏对象 3. Window：窗口对象 1. 创建 2. 方法 1. 与弹出框有关的方法： alert() 显示带有一段消息和一个确认按钮的警告框。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 * 如果用户点击确定按钮，则方法返回true * 如果用户点击取消按钮，则方法返回false prompt() 显示可提示用户输入的对话框。 * 返回值：获取用户输入的值 2. 与打开关闭有关的方法： close() 关闭浏览器窗口。 * 谁调用我 ，我关谁 open() 打开一个新的浏览器窗口 * 返回新的Window对象 3. 与定时器有关的方式 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 * 参数： 1. js代码或者方法对象 2. 毫秒值 * 返回值：唯一标识，用于取消定时器 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。 3. 属性： 1. 获取其他BOM对象： history location Navigator Screen: 2. 获取DOM对象 document 4. 特点 * Window对象不需要创建可以直接使用 window使用。 window.方法名(); * window引用可以省略。 方法名(); 4. Location：地址栏对象 1. 创建(获取)： 1. window.location 2. location 2. 方法： * reload() 重新加载当前文档。刷新 3. 属性 * href 设置或返回完整的 URL。 5. History：历史记录对象 1. 创建(获取)： 1. window.history 2. history 2. 方法： * back() 加载 history 列表中的前一个 URL。 * forward() 加载 history 列表中的下一个 URL。 * go(参数) 加载 history 列表中的某个具体页面。 * 参数： * 正数：前进几个历史记录 * 负数：后退几个历史记录 3. 属性： * length 返回当前窗口历史列表中的 URL 数量。 DOM：* 概念： Document Object Model 文档对象模型 * 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作 * W3C DOM 标准被分为 3 个不同的部分： * 核心 DOM - 针对任何结构化文档的标准模型 * Document：文档对象 * Element：元素对象 * Attribute：属性对象 * Text：文本对象 * Comment:注释对象 * Node：节点对象，其他5个的父对象 * XML DOM - 针对 XML 文档的标准模型 * HTML DOM - 针对 HTML 文档的标准模型 * 核心DOM模型： * Document：文档对象 1. 创建(获取)：在html dom模型中可以使用window对象来获取 1. window.document 2. document 2. 方法： 1. 获取Element对象： 1. getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一 2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组 3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组 4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 2. 创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode() 3. 属性 * Element：元素对象 1. 获取/创建：通过document来获取和创建 2. 方法： 1. removeAttribute()：删除属性 2. setAttribute()：设置属性 * Node：节点对象，其他5个的父对象 * 特点：所有dom对象都可以被认为是一个节点 * 方法： * CRUD dom树： * appendChild()：向节点的子节点列表的结尾添加新的子节点。 * removeChild() ：删除（并返回）当前节点的指定子节点。 * replaceChild()：用新节点替换一个子节点。 * 属性： * parentNode 返回节点的父节点。 * HTML DOM 1. 标签体的设置和获取：innerHTML 2. 使用html元素对象的属性 3. 控制元素样式 1. 使用元素的style属性来设置 如： //修改样式方式1 div1.style.border = \"1px solid red\"; div1.style.width = \"200px\"; //font-size--&gt; fontSize div1.style.fontSize = \"20px\"; 2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。 事件监听机制：* 概念：某些组件被执行了某些操作后，触发某些代码的执行。 * 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 * 事件源：组件。如： 按钮 文本输入框... * 监听器：代码。 * 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 * 常见的事件： 1. 点击事件： 1. onclick：单击事件 2. ondblclick：双击事件 2. 焦点事件 1. onblur：失去焦点 2. onfocus:元素获得焦点。 3. 加载事件： 1. onload：一张页面或一幅图像完成加载。 4. 鼠标事件： 1. onmousedown 鼠标按钮被按下。 2. onmouseup 鼠标按键被松开。 3. onmousemove 鼠标被移动。 4. onmouseover 鼠标移到某元素之上。 5. onmouseout 鼠标从某元素移开。 ​ 5. 键盘事件： 1. onkeydown 某个键盘按键被按下。 2. onkeyup 某个键盘按键被松开。 3. onkeypress 某个键盘按键被按下并松开。 6. 选择和改变 1. onchange 域的内容被改变。 2. onselect 文本被选中。 7. 表单事件： 1. onsubmit 确认按钮被点击。 2. onreset 重置按钮被点击。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"03JavaScript基础笔记","date":"2020-05-10T06:26:45.534Z","updated":"2020-05-10T06:10:34.616Z","comments":true,"path":"2020/05/10/03javascript-ji-chu-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/03javascript-ji-chu-bi-ji/","excerpt":"","text":"1234567891011121314151617title: JavaScript复习（三）author: echodate: 2020-05-10 14:23:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - JavaScript - 复习tags: - JavaScript - 复习 [TOC] 今日内容1. JavaScript基础 JavaScript：* 概念： 一门客户端脚本语言 * 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 * 脚本语言：不需要编译，直接就可以被浏览器解析执行了 * 功能： * 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。 * JavaScript发展史： 1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C-- ，后来更名为：ScriptEase 2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript 3. 1996年，微软抄袭JavaScript开发出JScript语言 4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM) * ECMAScript：客户端脚本语言的标准 1. 基本语法： 1. 与html结合方式 1. 内部JS： * 定义&lt;script&gt;，标签体内容就是js代码 2. 外部JS： * 定义&lt;script&gt;，通过src属性引入外部的js文件 * 注意： 1. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。 2. &lt;script&gt;可以定义多个。 2. 注释 1. 单行注释：//注释内容 2. 多行注释：/*注释内容*/ 3. 数据类型： 1. 原始数据类型(基本数据类型)： 1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型) 2. string：字符串。 字符串 \"abc\" \"a\" 'abc' 3. boolean: true和false 4. null：一个对象为空的占位符 5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined 2. 引用数据类型：对象 4. 变量 * 变量：一小块存储数据的内存空间 * Java语言是强类型语言，而JavaScript是弱类型语言。 * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 * 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 * 语法： * var 变量名 = 初始化值; * typeof运算符：获取变量的类型。 * 注：null运算后得到的是object 5. 运算符 1. 一元运算符：只有一个运算数的运算符 ++，-- ， +(正号) * ++ --: 自增(自减) * ++(--) 在前，先自增(自减)，再运算 * ++(--) 在后，先运算，再自增(自减) * +(-)：正负号 * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换 * 其他类型转number： * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字） * boolean转number：true转为1，false转为0 2. 算数运算符 + - * / % ... 3. 赋值运算符 = += -+.... 4. 比较运算符 &gt; &lt; &gt;= &lt;= == ===(全等于) * 比较方式 1. 类型相同：直接比较 * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。 2. 类型不同：先进行类型转换，再比较 * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false 5. 逻辑运算符 &amp;&amp; || ! * 其他类型转boolean： 1. number：0或NaN为假，其他为真 2. string：除了空字符串(\"\")，其他都是true 3. null&amp;undefined:都是false 4. 对象：所有对象都为true 6. 三元运算符 ? : 表达式 var a = 3; var b = 4; var c = a &gt; b ? 1:0; * 语法： * 表达式? 值1:值2; * 判断表达式的值，如果是true则取值1，如果是false则取值2； 6. 流程控制语句： 1. if...else... 2. switch: * 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7) * switch(变量): case 值: * 在JS中,switch语句可以接受任意的原始数据类型 3. while 4. do...while 5. for 7. JS特殊语法： 1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议) 2. 变量的定义使用var关键字，也可以不使用 * 用： 定义的变量是局部变量 * 不用：定义的变量是全局变量(不建议) 8. 练习：99乘法表 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;99乘法表&lt;/title&gt; &lt;style&gt; td{ border: 1px solid; } &lt;/style&gt; &lt;script&gt; document.write(\"&lt;table align='center'&gt;\"); ​ //1.完成基本的for循环嵌套，展示乘法表 for (var i = 1; i &lt;= 9 ; i++) { document.write(““); for (var j = 1; j &lt;=i ; j++) { document.write(““); //输出 1 * 1 = 1 document.write(i + \" * \" + j + \" = \" + ( i*j) +\"&amp;nbsp;&amp;nbsp;&amp;nbsp;\"); document.write(\"&lt;/td&gt;\"); } /*//输出换行 document.write(\"&lt;br&gt;\");*/ document.write(\"&lt;/tr&gt;\"); } //2.完成表格嵌套 document.write(\"&lt;/table&gt;\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 2. 基本对象： 1. Function：函数(方法)对象 1. 创建： 1. var fun = new Function(形式参数列表,方法体); //忘掉吧 2. function 方法名称(形式参数列表){ 方法体 } 3. var 方法名 = function(形式参数列表){ 方法体 } 2. 方法： 3. 属性： length:代表形参的个数 4. 特点： 1. 方法定义是，形参的类型不用写,返回值类型也不写。 2. 方法是一个对象，如果定义名称相同的方法，会覆盖 3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关 4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数 5. 调用： 方法名称(实际参数列表); 2. Array:数组对象 1. 创建： 1. var arr = new Array(元素列表); 2. var arr = new Array(默认长度); 3. var arr = [元素列表]; 2. 方法 join(参数):将数组中的元素按照指定的分隔符拼接为字符串 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 3. 属性 length:数组的长度 4. 特点： 1. JS中，数组元素的类型可变的。 2. JS中，数组长度可变的。 3. Boolean 4. Date：日期对象 1. 创建： var date = new Date(); 2. 方法： toLocaleString()：返回当前date对象对应的时间本地字符串格式 getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差 5. Math：数学对象 1. 创建： * 特点：Math对象不用创建，直接使用。 Math.方法名(); 2. 方法： random():返回 0 ~ 1 之间的随机数。 含0不含1 ceil(x)：对数进行上舍入。 floor(x)：对数进行下舍入。 round(x)：把数四舍五入为最接近的整数。 3. 属性： PI 6. Number 7. String 8. RegExp：正则表达式对象 1. 正则表达式：定义字符串的组成规则。 1. 单个字符:[] 如： [a] [ab] [a-zA-Z0-9_] * 特殊符号代表特殊含义的单个字符: \\d:单个数字字符 [0-9] \\w:单个单词字符[a-zA-Z0-9_] 2. 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 {m,n}:表示 m&lt;= 数量 &lt;= n * m如果缺省： {,n}:最多n次 * n如果缺省：{m,} 最少m次 3. 开始结束符号 * ^:开始 * $:结束 2. 正则对象： 1. 创建 1. var reg = new RegExp(\"正则表达式\"); 2. var reg = /正则表达式/; 2. 方法 1. test(参数):验证指定的字符串是否符合正则定义的规范 9. Global 1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。 方法名(); 2. 方法： encodeURI():url编码 decodeURI():url解码 encodeURIComponent():url编码,编码的字符更多 decodeURIComponent():url解码 parseInt():将字符串转为数字 * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number isNaN():判断一个值是否是NaN * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。 3. URL编码 传智播客 = %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2 * BOM * DOM ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"02HTML&CSS课堂笔记","date":"2020-05-10T06:26:45.532Z","updated":"2020-05-10T06:08:32.223Z","comments":true,"path":"2020/05/10/02html-css-ke-tang-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/02html-css-ke-tang-bi-ji/","excerpt":"","text":"12345678910111213141516171819title: HTML&amp;&amp;CSS复习（二）author: echodate: 2020-05-10 14:13:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - HTML - CSS - 复习tags: - HTML - CSS - 复习 [TOC] 今日内容：1. HTML标签：表单标签 2. CSS： HTML标签：表单标签* 表单： * 概念：用于采集用户输入的数据的。用于和服务器进行交互。 * form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 * 属性： * action：指定提交数据的URL * method:指定提交方式 * 分类：一共7种，2种比较常用 * get： 1. 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。 2. 请求参数大小是有限制的。 3. 不太安全。 * post： 2. 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解) 2. 请求参数的大小没有限制。 3. 较为安全。 * 表单项中的数据要想被提交：必须指定其name属性 ​ * 表单项标签： * input：可以通过type属性值，改变元素展示的样式 * type属性： * text：文本输入框，默认值 * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 * password：密码输入框 * radio:单选框 * 注意： 1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。 2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值 3. checked属性，可以指定默认值 * checkbox：复选框 * 注意： 1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值 2. checked属性，可以指定默认值 * file：文件选择框 * hidden：隐藏域，用于提交一些信息。 * 按钮： * submit：提交按钮。可以提交表单 * button：普通按钮 * image：图片提交按钮 * src属性指定图片的路径 * label：指定输入项的文字描述信息 * 注意： * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 * select: 下拉列表 * 子元素：option，指定列表项 * textarea：文本域 * cols：指定列数，每一行有多少个字符 * rows：默认多少行。 CSS：页面美化和布局控制1. 概念： Cascading Style Sheets 层叠样式表 * 层叠：多个样式可以作用在同一个html的元素上，同时生效 2. 好处： 1. 功能强大 2. 将内容展示和样式控制分离 * 降低耦合度。解耦 * 让分工协作更容易 * 提高开发效率 3. CSS的使用：CSS与html结合方式 1. 内联样式 * 在标签内使用style属性指定css代码 * 如：&lt;div style=\"color:red;\"&gt;hello css&lt;/div&gt; 2. 内部样式 * 在head标签内，定义style标签，style标签的标签体内容就是css代码 * 如： &lt;style&gt; div{ color:blue; } &lt;/style&gt; &lt;div&gt;hello css&lt;/div&gt; 3. 外部样式 1. 定义css资源文件。 2. 在head标签内，定义link标签，引入外部的资源文件 * 如： * a.css文件： div{ color:green; } &lt;link rel=\"stylesheet\" href=\"css/a.css\"&gt; &lt;div&gt;hello css&lt;/div&gt; &lt;div&gt;hello css&lt;/div&gt; * 注意： * 1,2,3种方式 css作用范围越来越大 * 1方式不常用，后期常用2,3 * 3种格式可以写为： &lt;style&gt; @import \"css/a.css\"; &lt;/style&gt; 4. css语法： * 格式： 选择器 { 属性名1:属性值1; 属性名2:属性值2; ... } * 选择器:筛选具有相似特征的元素 * 注意： * 每一对属性需要使用；隔开，最后一对属性可以不加； 5. 选择器：筛选具有相似特征的元素 * 分类： 1. 基础选择器 1. id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一 * 语法：#id属性值{} 2. 元素选择器：选择具有相同标签名称的元素 * 语法： 标签名称{} * 注意：id选择器优先级高于元素选择器 3. 类选择器：选择具有相同的class属性值的元素。 * 语法：.class属性值{} * 注意：类选择器选择器优先级高于元素选择器 2. 扩展选择器： 1. 选择所有元素： * 语法： *{} 2. 并集选择器： * 选择器1,选择器2{} 3. 子选择器：筛选选择器1元素下的选择器2元素 * 语法： 选择器1 选择器2{} 4. 父选择器：筛选选择器2的父元素选择器1 * 语法： 选择器1 &gt; 选择器2{} 5. 属性选择器：选择元素名称，属性名=属性值的元素 * 语法： 元素名称[属性名=\"属性值\"]{} 6. 伪类选择器：选择一些元素具有的状态 * 语法： 元素:状态{} * 如： &lt;a&gt; * 状态： * link：初始化的状态 * visited：被访问过的状态 * active：正在访问状态 * hover：鼠标悬浮状态 6. 属性 1. 字体、文本 * font-size：字体大小 * color：文本颜色 * text-align：对其方式 * line-height：行高 2. 背景 * background： 3. 边框 * border：设置边框，符合属性 4. 尺寸 * width：宽度 * height：高度 5. 盒子模型：控制布局 * margin：外边距 * padding：内边距 * 默认情况下内边距会影响整个盒子的大小 * box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 * float：浮动 * left * right 案例：&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;style&gt; *{ margin: 0px; padding: 0px; box-sizing: border-box; } body{ background: url(\"img/register_bg.png\") no-repeat center; padding-top: 25px; } .rg_layout{ width: 900px; height: 500px; border: 8px solid #EEEEEE; background-color: white; /*让div水平居中*/ margin: auto; } .rg_left{ /*border: 1px solid red;*/ float: left; margin: 15px; } .rg_left &gt; p:first-child{ color:#FFD026; font-size: 20px; } .rg_left &gt; p:last-child{ color:#A6A6A6; font-size: 20px; } ​ .rg_center{ float: left; / border: 1px solid red;/ } .rg_right{ /*border: 1px solid red;*/ float: right; margin: 15px; } .rg_right &gt; p:first-child{ font-size: 15px; } .rg_right p a { color:pink; } .td_left{ width: 100px; text-align: right; height: 45px; } .td_right{ padding-left: 50px ; } #username,#password,#email,#name,#tel,#birthday,#checkcode{ width: 251px; height: 32px; border: 1px solid #A6A6A6 ; /*设置边框圆角*/ border-radius: 5px; padding-left: 10px; } #checkcode{ width: 110px; } #img_check{ height: 32px; vertical-align: middle; } #btn_sub{ width: 150px; height: 40px; background-color: #FFD026; border: 1px solid #FFD026 ; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"rg_layout\"&gt; &lt;div class=\"rg_left\"&gt; &lt;p&gt;新用户注册&lt;/p&gt; &lt;p&gt;USER REGISTER&lt;/p&gt; &lt;/div&gt; &lt;div class=\"rg_center\"&gt; &lt;div class=\"rg_form\"&gt; &lt;!--定义表单 form--&gt; &lt;form action=\"#\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"username\"&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"username\" id=\"username\" placeholder=\"请输入用户名\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"password\"&gt;密码&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"password\" name=\"password\" id=\"password\" placeholder=\"请输入密码\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"email\"&gt;Email&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"email\" name=\"email\" id=\"email\" placeholder=\"请输入邮箱\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"name\"&gt;姓名&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"name\" id=\"name\" placeholder=\"请输入姓名\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"tel\"&gt;手机号&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"tel\" id=\"tel\" placeholder=\"请输入手机号\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"male\"&gt; 男 &lt;input type=\"radio\" name=\"gender\" value=\"female\"&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"birthday\"&gt;出生日期&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"date\" name=\"birthday\" id=\"birthday\" placeholder=\"请输入出生日期\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=\"td_left\"&gt;&lt;label for=\"checkcode\" &gt;验证码&lt;/label&gt;&lt;/td&gt; &lt;td class=\"td_right\"&gt;&lt;input type=\"text\" name=\"checkcode\" id=\"checkcode\" placeholder=\"请输入验证码\"&gt; &lt;img id=\"img_check\" src=\"img/verify_code.jpg\"&gt; &lt;/td&gt; &lt;/tr&gt; ​ &lt;/form&gt; ​ &lt;/div&gt; &lt;div class=\"rg_right\"&gt; &lt;p&gt;已有账号?&lt;a href=\"#\"&gt;立即登录&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; ​ ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"01HTML课堂笔记","date":"2020-05-10T06:26:45.527Z","updated":"2020-05-10T06:07:07.321Z","comments":true,"path":"2020/05/10/01html-ke-tang-bi-ji/","link":"","permalink":"http://39.99.158.50/2020/05/10/01html-ke-tang-bi-ji/","excerpt":"","text":"1234567891011121314151617title: HTML复习（一）author: echodate: 2020-05-10 14:03:07img:top:cover:coverImg:password:toc:mathjax:summary:categories: - HTML - 复习tags: - HTML - 复习 [TOC] 今日内容1. web概念概述 2. HTML web概念概述* JavaWeb： * 使用Java语言开发基于互联网的项目 * 软件架构： 1. C/S: Client/Server 客户端/服务器端 * 在用户本地有一个客户端程序，在远程有一个服务器端程序 * 如：QQ，迅雷... * 优点： 1. 用户体验好 * 缺点： 1. 开发、安装，部署，维护 麻烦 2. B/S: Browser/Server 浏览器/服务器端 * 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序 * 优点： 1. 开发、安装，部署，维护 简单 * 缺点： 1. 如果应用过大，用户的体验可能会受到影响 2. 对硬件要求过高 * B/S架构详解 * 资源分类： 1. 静态资源： * 使用静态网页开发技术发布的资源。 * 特点： * 所有用户访问，得到的结果是一样的。 * 如：文本，图片，音频、视频, HTML,CSS,JavaScript * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源 2. 动态资源： * 使用动态网页及时发布的资源。 * 特点： * 所有用户访问，得到的结果可能不一样。 * 如：jsp/servlet,php,asp... * 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 * 我们要学习动态资源，必须先学习静态资源！ * 静态资源： * HTML：用于搭建基础网页，展示页面的内容 * CSS：用于美化页面，布局页面 * JavaScript：控制页面的元素，让页面有一些动态的效果 HTML1. 概念：是最基础的网页开发语言 * Hyper Text Markup Language 超文本标记语言 * 超文本: * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本. * 标记语言: * 由标签构成的语言。&lt;标签名称&gt; 如 html，xml * 标记语言不是编程语言 2. 快速入门： * 语法： 1. html文档后缀名 .html 或者 .htm 2. 标签分为 1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt; 2. 自闭和标签：开始标签和结束标签在一起。如 &lt;br/&gt; 3. 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt; 正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 4. 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 5. html的标签不区分大小写，但是建议使用小写。 * 代码： &lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color='red'&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color='green'&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt;/html&gt; 3. 标签学习： 1. * html:html文档的根标签 * head：头标签。用于指定html文档的一些属性。引入外部的资源 * title：标题标签。 * body：体标签 * &lt;!DOCTYPE html&gt;：html5中定义该文档是html文档 2. 文本标签：和文本有关的标签 * 注释：&lt;!-- 注释内容 --&gt; * &lt;h1&gt; to &lt;h6&gt;：标题标签 * h1~h6:字体大小逐渐递减 * &lt;p&gt;：段落标签 * &lt;br&gt;：换行标签 * &lt;hr&gt;：展示一条水平线 * 属性： * color：颜色 * width：宽度 * size：高度 * align：对其方式 * center：居中 * left：左对齐 * right：右对齐 * &lt;b&gt;：字体加粗 * &lt;i&gt;：字体斜体 * &lt;font&gt;:字体标签 * &lt;center&gt;:文本居中 * 属性： * color：颜色 * size：大小 * face：字体 * 属性定义： * color： 1. 英文单词：red,green,blue 2. rgb(值1，值2，值3)：值的范围：0~255 如 rgb(0,0,255) 3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF * width： 1. 数值：width='20' ,数值的单位，默认是 px(像素) 2. 数值%：占比相对于父元素的比例 * 案例：公司简介 &lt;!DOCTYPE html&gt; &lt;html lang=\"ch\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;黑马程序员简介&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; 公司简介 &lt;/h1&gt; &lt;hr color=\"#ffd700\"&gt; &lt;p&gt; &lt;font color=\"#FF0000\"&gt;\"中关村黑马程序员训练营\"&lt;/font&gt;是由&lt;b&gt;&lt;i&gt;传智播客&lt;/i&gt;&lt;/b&gt;联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。 &lt;/p&gt; &lt;p&gt; 目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。 &lt;/p&gt; &lt;p&gt; 黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。 中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。 &lt;/p&gt; &lt;p&gt; 一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。 &lt;/p&gt; &lt;hr color=\"#ffd700\"&gt; &lt;font color=\"gray\" size=\"2\"&gt; &lt;center&gt; 江苏传智播客教育科技股份有限公司&lt;br&gt; 版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882 &lt;/center&gt; &lt;/font&gt; &lt;/body&gt; &lt;/html&gt; ​​​ 3. 图片标签： * img：展示图片 * 属性： * src：指定图片的位置 * 代码： &lt;!--展示一张图片 img--&gt; &lt;img src=\"image/jingxuan_2.jpg\" align=\"right\" alt=\"古镇\" width=\"500\" height=\"500\"/&gt; &lt;!-- 相对路径 * 以.开头的路径 * ./：代表当前目录 ./image/1.jpg * ../:代表上一级目录 --&gt; &lt;img src=\"./image/jiangwai_1.jpg\"&gt; &lt;img src=\"../image/jiangwai_1.jpg\"&gt; 4. 列表标签： * 有序列表： * ol: * li: * 无序列表： * ul: * li: 5. 链接标签： * a:定义一个超链接 * 属性： * href：指定访问资源的URL(统一资源定位符) * target：指定打开资源的方式 * _self:默认值，在当前页面打开 * _blank：在空白页面打开 * 代码： &lt;!--超链接 a--&gt; &lt;a href=\"http://www.itcast.cn\"&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=\"http://www.itcast.cn\" target=\"_self\"&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=\"http://www.itcast.cn\" target=\"_blank\"&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=\"./5_列表标签.html\"&gt;列表标签&lt;/a&gt;&lt;br&gt; &lt;a href=\"mailto:itcast@itcast.cn\"&gt;联系我们&lt;/a&gt; &lt;br&gt; &lt;a href=\"http://www.itcast.cn\"&gt;&lt;img src=\"image/jiangwai_1.jpg\"&gt;&lt;/a&gt; 6. div和span： * div:每一个div占满一整行。块级标签 * span：文本信息在一行展示，行内标签 内联标签 7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签。 1. &lt;header&gt;：页眉 2. &lt;footer&gt;：页脚 8. 表格标签： * table：定义表格 * width：宽度 * border：边框 * cellpadding：定义内容和单元格的距离 * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、 * bgcolor：背景色 * align：对齐方式 * tr：定义行 * bgcolor：背景色 * align：对齐方式 * td：定义单元格 * colspan：合并列 * rowspan：合并行 * th：定义表头单元格 * &lt;caption&gt;：表格标题 * &lt;thead&gt;：表示表格的头部分 * &lt;tbody&gt;：表示表格的体部分 * &lt;tfoot&gt;：表示表格的脚部分 案例：旅游网站首页1. 确定使用table来完成布局 2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt; 3. 如果某一行有多个单元格，则使用 &lt;tr&gt; &lt;td&gt; &lt;table&gt;&lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; 4. 代码实现 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;黑马旅游网&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--采用table来完成布局--&gt; &lt;!--最外层的table，用于整个页面的布局--&gt; &lt;table width=\"100%\" align=\"center\"&gt; &lt;!-- 第1行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"image/top_banner.jpg\" width=\"100%\" alt=\"\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第2行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table width=\"100%\" align=\"center\"&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"image/logo.jpg\" alt=\"\"&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/search.png\" alt=\"\"&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/hotel_tel.png\" alt=\"\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第3行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table width=\"100%\" align=\"center\"&gt; &lt;tr bgcolor=\"#ffd700\" align=\"center\" height=\"45\" &gt; &lt;td&gt; &lt;a href=\"\"&gt;首页&lt;/a&gt; &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第4行 轮播图 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"image/banner_3.jpg\" alt=\"\" width=\"100%\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第5行 黑马精选--&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"image/icon_5.jpg\" alt=\"\"&gt; 黑马精选 &lt;hr color=\"#ffd700\" &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第6行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=\"center\" width=\"95%\"&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_1.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_1.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_1.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_1.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第7行 国内游 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"image/icon_6.jpg\" alt=\"\"&gt; 国内游 &lt;hr color=\"#ffd700\" &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第8行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=\"center\" width=\"95%\"&gt; &lt;tr&gt; &lt;td rowspan=\"2\"&gt; &lt;img src=\"image/guonei_1.jpg\" alt=\"\"&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_2.jpg\" alt=\"\" height=\"100%\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_2.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_2.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_2.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_2.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_2.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; ​​ ​ ​ ​ ​ 境外游 &lt;!-- 第10行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=\"center\" width=\"95%\"&gt; &lt;tr&gt; &lt;td rowspan=\"2\"&gt; &lt;img src=\"image/jiangwai_1.jpg\" alt=\"\"&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_3.jpg\" alt=\"\" height=\"100%\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=\"image/jiangxuan_3.jpg\" alt=\"\"&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=\"red\"&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; ​​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ xxxx科技股份有限公司 版权所有Copyright 2006-2018©, All Rights Reserved 苏ICP备16607882 &lt;/table&gt; ​​ ​ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"如何设置docker服务器和容器的自启动","slug":"如何设置docker服务器和容器的自启动","date":"2019-06-27T14:29:57.000Z","updated":"2020-04-27T14:33:10.817Z","comments":true,"path":"2019/06/27/ru-he-she-zhi-docker-fu-wu-qi-he-rong-qi-de-zi-qi-dong/","link":"","permalink":"http://39.99.158.50/2019/06/27/ru-he-she-zhi-docker-fu-wu-qi-he-rong-qi-de-zi-qi-dong/","excerpt":"","text":"[TOC] docker设置自动启动一、docker服务设置自动启动查看已启动的服务 systemctl list-units –type=service 查看是否设置开机启动 systemctl list-unit-files | grep enable 设置开机启动 systemctl enable docker.service 关闭开机启动 systemctl disable docker.service 二、docker容器设置自动启动启动时加 --restart=always docker run -tid –name isaler_v0.0.11 -p 8081:8080 –restart=always` 12345Flag Descriptionno 不自动重启容器. (默认value)on-failure 容器发生error而退出(容器退出状态不为0)重启容器unless-stopped 在容器已经stop掉或Docker stoped/restarted的时候才重启容器always 在容器已经stop掉或Docker stoped/restarted的时候才重启容器 如果已经过运行的项目 如果已经启动的项目，则使用update更新： docker update --restart=always isaler_v0.0.11 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"linux","slug":"linux","permalink":"http://39.99.158.50/categories/linux/"},{"name":"docker","slug":"linux/docker","permalink":"http://39.99.158.50/categories/linux/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://39.99.158.50/tags/linux/"},{"name":"docker","slug":"docker","permalink":"http://39.99.158.50/tags/docker/"}],"author":"echo"},{"title":"如何在linux上装jdk1.8并配置环境","slug":"如何在linux上装jdk1-8并配置环境","date":"2019-06-27T13:13:17.000Z","updated":"2020-04-27T14:29:27.641Z","comments":true,"path":"2019/06/27/ru-he-zai-linux-shang-zhuang-jdk1-8-bing-pei-zhi-huan-jing/","link":"","permalink":"http://39.99.158.50/2019/06/27/ru-he-zai-linux-shang-zhuang-jdk1-8-bing-pei-zhi-huan-jing/","excerpt":"","text":"[TOC] 本文主要介绍的是如何是Linux环境下安装JDK的，因为Linux环境下，很多时候也离不开Java的，下面笔者就和大家一起分享如何jdk1.8的过程吧。 1、安装环境操作系统：CentOS7 64位 jdk版本：1.8 工具：Xshell6、Xftp6 说明：Xshell6用于远程连接linux，Xftp用于上传资源到linux，两款软件是配合使用的可自行百度个人使用是免费的 2、安装步骤第一步：下载Linux环境下的jdk1.8安装包 点击移步下载 第二步：把下载安装包，上传至服务器中。Xftp的使用方法就不讲了 ，自信百度 第三步：解压安装包 将我们下载好的安装包上传至服务器，进行解压，使用Xshell远程操作 解压命令：tar -zxvf [里面为你的jdk压缩包名] 解压完成后，可以在当前目录下看到一个名字为jdk1.8.0_171的文件 3、配置环境变量配置环境变量的配置文件vim /etc/profile vim /etc/profile 拖到文件最后加上如下字符 JAVA_HOME=/opt/jdk1.8.0_171PATH=/opt/jdk1.8.0_171/bin:$PATHexport JAVA_HOME PATH 接着，按ESC键，然后:wq保存退出，输入reboot使服务器重启使jdk环境变量生效 查看jdk版本 输入 java -version或javac -version 出现版本号就代表安装成功了 如果没有就去看看profile里是不是配置错了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"linux jdk","slug":"linux-jdk","permalink":"http://39.99.158.50/categories/linux-jdk/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://39.99.158.50/tags/linux/"},{"name":"jdk","slug":"jdk","permalink":"http://39.99.158.50/tags/jdk/"}],"author":"echo"},{"title":"Hexo博客主题美化之新增看板娘","slug":"Hexo博客主题美化之新增看板娘","date":"2019-06-26T13:31:55.000Z","updated":"2020-04-26T14:12:54.628Z","comments":true,"path":"2019/06/26/hexo-bo-ke-zhu-ti-mei-hua-zhi-xin-zeng-kan-ban-niang/","link":"","permalink":"http://39.99.158.50/2019/06/26/hexo-bo-ke-zhu-ti-mei-hua-zhi-xin-zeng-kan-ban-niang/","excerpt":"","text":"Hexo博客主题美化之新增看板娘效果 教程①首先检查博客主目录下面的 package.json里是否有\"hexo-helper-live2d\": \"^3.0.3\",依赖，有的话可以先卸载 使用命令：npm uninstall hexo-helper-live2d ②安装模块，如下： npm install --save hexo-helper-live2d 注意：命令都是在你的博客主目录执行！！！！ 安装完成之后在package.json会看到安装的model 此时再去 node_moduels目录下，可以看到有如下文件夹，这些都是动画主配置 ③输入以下命令，下载相应的模型，将 packagename 更换成模型名称即可，更多模型选择请点击此处 $ npm install packagename 例如：npm install live2d-widget-model-haruto ④打开博客根目录下的 _config.yml 文件，添加如下代码： 1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-haruto #模型名称 就是你下的 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: false #是否在手机端显示 设置好过后我们就拥有了一个卡通人物 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"-hexo -live2d -主题","slug":"hexo-live2d-主题","permalink":"http://39.99.158.50/categories/hexo-live2d-主题/"}],"tags":[{"name":"live2d","slug":"live2d","permalink":"http://39.99.158.50/tags/live2d/"},{"name":"hexo","slug":"hexo","permalink":"http://39.99.158.50/tags/hexo/"}],"author":"echo"},{"title":"live2d看板娘一览图","slug":"live2d看板娘一览图","date":"2019-06-26T13:04:11.000Z","updated":"2020-04-26T15:02:05.099Z","comments":true,"path":"2019/06/26/live2d-kan-ban-niang-yi-lan-tu/","link":"","permalink":"http://39.99.158.50/2019/06/26/live2d-kan-ban-niang-yi-lan-tu/","excerpt":"","text":"live2d看板娘一览图模型下载地址：点击移步搭建教程：点击移步模型预览live2d-widget-model-chitose live2d-widget-model-epsilon2_1 live2d-widget-model-gf live2d-widget-model-izumi live2d-widget-model-koharu live2d-widget-model-miku live2d-widget-model-ni-j live2d-widget-model-nico live2d-widget-model-nietzschelive2d-widget-model-nipsilon live2d-widget-model-nito live2d-widget-model-shizuku live2d-widget-model-tororo live2d-widget-model-tsumiki live2d-widget-model-unitychan live2d-widget-model-wanko live2d-widget-model-z16 live2d-widget-model-hibiki live2d-widget-model-hijiki document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"-live2d -主题","slug":"live2d-主题","permalink":"http://39.99.158.50/categories/live2d-主题/"}],"tags":[{"name":"-live2d -hexo","slug":"live2d-hexo","permalink":"http://39.99.158.50/tags/live2d-hexo/"}],"author":"echo"},{"title":"使用Hexo为博客更换自己喜欢的主题","slug":"使用Hexo为博客更换自己喜欢的主题","date":"2019-06-26T11:58:05.000Z","updated":"2020-04-26T13:58:07.792Z","comments":true,"path":"2019/06/26/shi-yong-hexo-wei-bo-ke-geng-huan-zi-ji-xi-huan-de-zhu-ti/","link":"","permalink":"http://39.99.158.50/2019/06/26/shi-yong-hexo-wei-bo-ke-geng-huan-zi-ji-xi-huan-de-zhu-ti/","excerpt":"","text":"Hexo为博客更换自己喜欢的主题博客也搭建好了，文章也会写了,但是默认主题巨丑怎么办，那我们就自定义自己喜欢的主题 点击此处进入 Hexo 官网的主题专栏 我们要做的就是把主题克隆过来，在此我们以主题 Nexmoe 为例，点进去我们就可以看见该主题作者的博客，点击Clone or download 复制https地址，在博客根目录的themes（比如我的D:\\blog\\themes）打开Git命令行输入 git clone https://github.com/theme-nexmoe/hexo-theme-nexmoe.git 待下载完成后即可在 themes 目录下生成 hexo-theme-nexmoe 文件夹，然后打开 blog 文件夹下的配置文件 _config.yml ，找到关键字 theme，修改参数为：hexo-theme-nexmoe（其他主题修改成相应名称即可），再次注意冒号后面有一个空格！ 返回 Hexo 目录，右键 Git Bash Here ，输入以下命令开始部署主题： 123hexo cleanhexo ghexo s 此时打开浏览器，访问 http://localhost:4000/ 就可看见我们的主题已经更换了，如果感觉效果满意，我们就可以把它部署到Github上了 hexo d 此时访问自己的博客即可看见更换后的主题，但我们仍然需要对主题的相关配置进行修改，比如网站标题，图标等等具体配置请移步《快速开始》 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"hexo","slug":"hexo","permalink":"http://39.99.158.50/categories/hexo/"},{"name":"主题","slug":"hexo/主题","permalink":"http://39.99.158.50/categories/hexo/主题/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://39.99.158.50/tags/hexo/"},{"name":"主题","slug":"主题","permalink":"http://39.99.158.50/tags/主题/"}],"author":"echo"},{"title":"使用Hexo和github搭建自己的博客超详细奶妈级别教程","slug":"使用Hexo和github搭建自己的博客超详细奶妈级别教程","date":"2019-06-25T10:12:01.000Z","updated":"2020-04-26T12:57:47.534Z","comments":true,"path":"2019/06/25/shi-yong-hexo-he-github-da-jian-zi-ji-de-bo-ke-chao-xiang-xi-nai-ma-ji-bie-jiao-cheng/","link":"","permalink":"http://39.99.158.50/2019/06/25/shi-yong-hexo-he-github-da-jian-zi-ji-de-bo-ke-chao-xiang-xi-nai-ma-ji-bie-jiao-cheng/","excerpt":"","text":"[TOC] 入门简介博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。今天我们学习的是Hexo+Github的方式。 Github Pages可以被认为是用户编写的、托管在github上的静态网页。使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 环境安装Git安装百度搜索git，点击进入 点击Downloads 接着 不知道的朋友可以鼠标右击此电脑（或我的电脑）点属性就可以看到了! 然后无限下一步安装就行了（注意安装目录不要有中文字符和空格） git安装好在任何一个文件夹右击鼠标后出现以下选项，证明Git安装好了 安装Nodejs百度搜索nodejs或直接点击此处进入下载官网 然后无限下一步安装就行 检验Git是否安装成功在桌面右键鼠标，可以看到菜单里多了 Git GUI Here 和 Git Bash Here两个选项，第一个是图形界面的Git操作，另一个是命令行，选择第二个 123456输入``git --version` `node -v `npm -v` 如果出现版本号则表示安装成功 安装Hexo新建一个文件夹如：我的文件夹为：D\\blog），博客相关文件将储存在此文件夹下，在该文件夹下右键鼠标，点击 Git Bash Here，输入以下 npm 命令即可安装，第一个命令表示安装 hexo，第二个命令表示安装 hexo 部署到 git page 的 deployer，如图所示即为安装成功 npm install hexo-cli -gnpm install hexo-deployer-git --save Hexo配置在创的文件夹下右键鼠标，点击 Git Bash Here，输入以下命令，如图所示则安装成功 hexo init Hexo安装完成后，将在blog目录中新建所需要的文件，如下 Hexo使用命令1234567hexo sever ： #启动博客程序``hexo clean： #用来清理缓存文件``hexo g ： #生成文件``hexo s ： #运行本地服务器``hexo d ： #上传到服务器 出现如下界面就可以访问博客啦，在浏览器地址栏输入http://localhost:4000就可以访问了 访问页面 将博客部署到Github上注册Github账户点击此处访问github官网，点击 Sign Up 注册账户 登录后点击! ​ 配置SSH密钥只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步，在你第一次新建的文件夹里面（如：我的文件夹为：D\\blog） Git Bash Here 输入以下命令： 1234567891011121314151617181920212223 `$ ssh-keygen -t rsa -C \"your email@example.com\"` `//引号里面填写你的邮箱地址`之后会出现： `Generating public/private rsa key pair.` Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): `//到这里可以直接回车将密钥按默认文件进行存储`然后会出现： `Enter passphrase (empty for no passphrase):` //这里是要你输入密码，其实不需要输什么密码，直接回车就行 `Enter same passphrase again:` 接下来屏幕会显示： `Your identification has been saved in /c/Users/you/.ssh/id_rsa.` Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 这里是各种字母数字组成的字符串，结尾是你的邮箱 The key's randomart image is: `这里也是各种字母数字符号组成的字符串` 运行以下命令，将公钥的内容复制到系统粘贴板上也可以去C盘的用户目录下 比如我的C:\\Users\\liuxin\\.ssh找到id_rsa.pub打开复制 $ clip &lt; ~/.ssh/id_rsa.pub GitHub 账户中添加你的公钥①登陆 GitHub，进入 Settings： 测试输入以下命令：注意：git@github.com不要做任何更改！ ssh -T git@github.com 之后会显示： 输入 yes 后会显示： 此时表示设置正确 配置Git个人信息Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理 git config --global user.name \"此处填你的用户名\"git config --global user.email \"此处填你的邮箱\" 到此为止 SSH Key 配置成功，本机已成功连接到 Github 将本地的 Hexo 文件更新到 Github 的库中登录 Github 打开自己的项目 your name.github.io 鼠标移到 Clone or download 按钮，选择 Use SSH 打开你创建的文件夹（如：D:\\blog）打开该文件夹下的 _config.yml 文件,我的是部署过得所以文件比你们的多 然后在D/blog目录下点击 Git Bash Here输入以下命令 hexo g hexo d 或直接执行 hexo g -d 执行完之后会让你输入你的 Github 的账号和密码，如果此时报以下错误，说明你的 deployer 没有安装成功 ERROR Deployer not found: git 需要执行以下命令再安装一次： npm install hexo-deployer-git --save 再执行 hexo g -d，你的博客就会部署到 Github 上了 访问博客进入你的项目点击settings,选择Options，往下翻找到GitHub Pages里面就是你的博客地址，现在每个人都可以通过此链接访问你的博客了！ Hexo博客发表文章新建一个空文章输入以下命令，会在项目D:\\blog\\source_posts中生成 文章标题.md 文件，文章标题根据需要命名 hexo n \"文章标题\" 也可以直接在D:\\blog\\source_posts目录下右键鼠标新建文本文档，改后缀为 .md 即可，这种方法比较方便 用编辑器编写文章:推荐几款好用的md编辑器md 全称 Markdown 1.Typora 2.MarkdownPad2 3.BookPad 4.小书匠 5.Sublime Text 3 文章标题，标签，分类，封面图片，摘要等，可以在 Front-matter 里面配置（Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，官方文档：https://hexo.io/zh-cn/docs/front-matter ），举个例子： layout: 页面布局（配合主题文档使用）title: 文章名称date: 文章日期comments: 文章是否开启评论photos: 文章封面图（仅部分主题支持）tags: 文章标签一 文章标签二categories: 文章分类description: 文章描述，即要在首页显示的摘要（仅部分主题支持） 这里是摘要 &lt;!-- more --&gt; 这里是正文 注意：description 和 &lt;!-- more --&gt; 方式显示摘要二选一即可，部分主题不支持description，每个配置英文冒号后面要空一格，不同主题配置有所差异，具体要参考主题文档 当我们用编辑器写好文章后，可以使用以下命令将其推送到服务器上 hexo clean hexo g hexo d 现在访问你的博客就可以看见写好的文章啦！ 好了现在就可以邀请你朋友一起看你的个人博客啦！！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"-hexo","slug":"hexo","permalink":"http://39.99.158.50/categories/hexo/"}],"tags":[{"name":"-hexo","slug":"hexo","permalink":"http://39.99.158.50/tags/hexo/"}],"author":"echo"},{"title":"Eclipse怎么设置类头信息的方法","slug":"Eclipse怎么设置类头信息的方法","date":"2019-05-05T14:10:16.000Z","updated":"2020-05-05T14:45:01.191Z","comments":true,"path":"2019/05/05/eclipse-zen-me-she-zhi-lei-tou-xin-xi-de-fang-fa/","link":"","permalink":"http://39.99.158.50/2019/05/05/eclipse-zen-me-she-zhi-lei-tou-xin-xi-de-fang-fa/","excerpt":"","text":"首先打开Eclipse配置选项：Window-&gt;Preference-&gt;Java-&gt;Code Style-&gt;Code Template 下面是我列举的几个常用的模板1、Files /** @Title: ${file_name}@Package ${package_name}@Description: ${todo}(用一句话描述该文件做什么)@author （这里是作者，不写默认是你电脑的用户名，可以自定义）@date ${date}*/ 2、Types /** @Description: ${todo}(这里用一句话描述这个类的作用)@CopyRightInformation : XXX(公司名称)@ApplicationName: ${project_name}@Title: ${file_name}@author （这里是作者，不写默认是你电脑的用户名，可以自定义）@date: ${date} ${time}${tags}*/3、Constructors /** ${tags}*/4、Methods /** @Title: ${enclosing_method}@Description: ${todo}(这里用一句话描述这个方法的作用)@author: （这里是作者，不写默认是你电脑的用户名，可以自定义）@date: ${date} ${time}@param ${tags} 参数@return ${return_type} 返回类型@throws*/5、Overriding methods /** Title: ${enclosing_method} Description: ${tags}${see_to_overridden}*/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"eclipse","slug":"eclipse","permalink":"http://39.99.158.50/categories/eclipse/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://39.99.158.50/tags/eclipse/"}],"author":"echo"},{"title":"水仙花数","slug":"水仙花数","date":"2018-11-10T14:10:03.000Z","updated":"2020-05-07T12:01:16.544Z","comments":true,"path":"2018/11/10/shui-xian-hua-shu/","link":"","permalink":"http://39.99.158.50/2018/11/10/shui-xian-hua-shu/","excerpt":"","text":"简介水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身（例如：1^3 + 5^3+ 3^3 = 153）。 代码123456789101112131415161718192021public class waterFlowerNum { public static void waterFlower() { // 求出个、十、百的数字 for(int i=100;i&lt;1000;i++) { int g = i/1%10; int s = i/10%10; int b = i/100; if(g*g*g + s*s*s + b*b*b==i) { System.out.print(i + \" \"); } } } public static void main(String[] args) { waterFlower(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java","slug":"java","permalink":"http://39.99.158.50/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://39.99.158.50/tags/java/"}],"author":"echo"},{"title":"快速排序","slug":"快速排序","date":"2018-11-10T05:54:08.000Z","updated":"2020-05-05T14:45:01.199Z","comments":true,"path":"2018/11/10/kuai-su-pai-xu/","link":"","permalink":"http://39.99.158.50/2018/11/10/kuai-su-pai-xu/","excerpt":"","text":"[TOC] 快速排序( ( ( ( 分区交换排序) ) ) )快速排序（Quick Sorting）是迄今为止所有内排序算法中速度最快的一种。它的 基本思想是：任取待排序序列中的某个元素作为标准（ 也称为支点、界点， 一般取第一个元素），通过一次划分，将待排元素分为左右两个子序列，左子序列元素的排序码均小于基准元素的排序码，右子序列的排序码则大于或等于基准元素的排序码，然后分别对两个子序列继续进行划分，直至每一个序列只有一个元素为止。最后得到的序列便是有序序列。 一次划分的具体过程​ 1．low指向待划分区域首元素，high指向待划分区域尾元素;​ 2．R[0]=R[low] (为了减少数据的移动,将作为标准的元素暂存到R[0]中，最后再放入最终位置) ; high从后往前移动直到R[high].key&lt;R[0].key; R[low]=R[high], low++; low从前往后移动直到R[low].key&gt;=R[0].key; R[high]=R[low], high–; goto 3; 直到low==high时，R[low]=R[0] (即将作为标准的元素放到其最终位置) 。概括地说, 一次划分就是从表的两端交替地向中间进行扫描,将小的放到左边, 大的放到右边, 作为标准的元素放到中间。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package test;public class QuickSort { public static void main(String[] args) { int[] a = {12,20,5,16,15,1,30,45,23,9,4,4}; int min = 0; int max = a.length-1; sort(a, min, max); for (int i : a) { System.out.println(i); } } /* * 首先需要一个数组存放所有的数据 * 定一个开始位置和一个结束为止 * 选择一个数作为准基数 */ public static void sort(int a[],int min,int max) { int key=a[min];//准基数 int start=min; //开始位置 int end =max;//结束位置 while(end&gt;start) { //循环条件是否数值交叉 //从后开始往前查找 while(end&gt;start&amp;&amp;a[end]&gt;=key) { //如果找到的值大于基数值，那么继续往下找，end-- end--; } //如果找到的值小于基数值，那么进行值交换 if(a[end]&lt;key) { int i=a[end]; a[end]=a[start]; a[start]=i; } //从前往后找 while(end&gt;start&amp;&amp;a[start]&lt;=key) { //如果找到的值小于基数值，那么继续往下找，start++ start++; } //如果找到的值大于基数值，那么进行值交换 if(a[start]&gt;key) { int i=a[start]; a[start]=a[end]; a[end]=i; } } //这部分的数据都是小于准基数，通过递归在进行一趟快排 if(start&gt;min) { sort(a, min, start-1); //开始位置为第一位，结束位置为关键索引-1 } if(end&lt;max) { sort(a, end+1, max); //开始位置为关键索引+1，结束位置最后一位 } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"算法","slug":"java基础/算法","permalink":"http://39.99.158.50/categories/java基础/算法/"}],"tags":[{"name":"java","slug":"java","permalink":"http://39.99.158.50/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://39.99.158.50/tags/算法/"}],"author":"echo"},{"title":"简单的冒泡排序","slug":"简单的冒泡排序","date":"2018-11-10T03:54:08.000Z","updated":"2020-05-05T14:45:01.204Z","comments":true,"path":"2018/11/10/jian-dan-de-mou-pao-pai-xu/","link":"","permalink":"http://39.99.158.50/2018/11/10/jian-dan-de-mou-pao-pai-xu/","excerpt":"","text":"[TOC] 冒泡排序介绍：冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。 排序思想：比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。快速 排序 介绍：快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。快速排序（Quick Sort）由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算法中速度最快的一种。冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为O(nlog(n))。 演示 代码1234567891011121314151617181920212223242526public class BubbleSortTest {public static void main(String[] args) { int[] arr = new int[]{43,42,56,75,64,58,97,86}; //冒泡排序 第一大轮 //八个元素比七轮 所以 arr.length - 1 for (int i = 0; i &lt; arr.length - 1; i++) { // 当 i=1时第二大轮 arr.length - 1 还要少一个 for (int j = 0; j &lt; arr.length - 1 - i; j++) { //当前一个比后一个数大时交换 if (arr[j] &gt; arr[j + 1 ]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } //遍历 for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t \"); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"算法","slug":"java基础/算法","permalink":"http://39.99.158.50/categories/java基础/算法/"}],"tags":[{"name":"java","slug":"java","permalink":"http://39.99.158.50/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://39.99.158.50/tags/算法/"}],"author":"echo"},{"title":"java中数组的复制、反转、查找操作(线性查找、二分法查找)","slug":"java中数组的复制、反转、查找操作-线性查找、二分法查找","date":"2018-11-10T02:54:08.000Z","updated":"2020-05-05T14:45:01.196Z","comments":true,"path":"2018/11/10/java-zhong-shu-zu-de-fu-zhi-fan-zhuan-cha-zhao-cao-zuo-xian-xing-cha-zhao-er-fen-fa-cha-zhao/","link":"","permalink":"http://39.99.158.50/2018/11/10/java-zhong-shu-zu-de-fu-zhi-fan-zhuan-cha-zhao-cao-zuo-xian-xing-cha-zhao-er-fen-fa-cha-zhao/","excerpt":"","text":"[TOC] 二分法查找的原理： 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void main(String[] args) {String[] arr = new String[] {“GG”,“MM”,“JJ”,“DD”,“BB”,“AA”}; //数组的复制(区别于数组的赋值：arr1 = arr) String[] arr1 = new String[arr.length]; for (int i = 0; i &lt; arr1.length; i++) { arr1[i] = arr[i]; } //数组的反转 for (int i = 0,j = arr.length -1;i &lt; j; i++,j--) { String temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } //遍历 for (int i = 0; i &lt; arr1.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); //数组的查找 （二分法查找） //前提 ：数组必须是有序的 int[] arr2 = new int[] {-90,-78,-77,0,123,345,657,875,899,990,999}; int dest = 345; int head = 0;//初始首索引值 int end = arr2.length -1;//初始的末索引 boolean isFlag = true; while(head &lt;= end) { int mid = (head + end) / 2; //得到索引的中间值 if (dest == arr2[mid]) { System.out.println(\"找到了指定的元素，位置为：\"+mid); isFlag = false; break; }else if (arr2[mid] &gt; dest) { end = mid -1; }else {//arr2{mid} &lt;dest head = mid + 1; } } if (isFlag) { System.out.println(\"很遗憾没有找到啦！\"); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"数组","slug":"java基础/数组","permalink":"http://39.99.158.50/categories/java基础/数组/"}],"tags":[{"name":"java","slug":"java","permalink":"http://39.99.158.50/tags/java/"},{"name":"数组","slug":"数组","permalink":"http://39.99.158.50/tags/数组/"}],"author":"echo"},{"title":"java实现杨辉三角","slug":"java实现杨辉三角","date":"2018-11-10T01:54:08.000Z","updated":"2020-05-05T14:45:01.197Z","comments":true,"path":"2018/11/10/java-shi-xian-yang-hui-san-jiao/","link":"","permalink":"http://39.99.158.50/2018/11/10/java-shi-xian-yang-hui-san-jiao/","excerpt":"","text":"使用二维数组打印一个 10 行杨辉三角。* 【提示】 1. 第一行有 1 个元素, 第 n 行有 n 个元素 2. 每一行的第一个元素和最后一个元素都是 1 3. 从第三行开始, 对于非第一个元素和最后一个元 素的元素。即：yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j]; 效果图： 代码： 12345678910111213141516171819202122232425262728293031public class YangHui {``public static void main(String[] args) {``` //1.声明并初始化二维数组 int[][] yanghui = new int[10][]; //2.给数组的元素赋值 for (int i = 0; i &lt; yanghui.length; i++) { yanghui[i] = new int[i+1];//第一行有1个元素 第二行有2个元素 //2.1给首末元素赋值 yanghui[i][0] = yanghui[i][i] = 1; //2.2给每行的非首末元素赋值 for (int j = 1; j &lt; yanghui[i].length - 1; j++) { yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j]; } } //3.遍历二维数组 for (int i = 0; i &lt; yanghui.length; i++) { for (int j = 0; j &lt; yanghui[i].length; j++) { System.out.print(yanghui[i][j] + \" \"); } System.out.println(); }`}` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"二维数组","slug":"java基础/二维数组","permalink":"http://39.99.158.50/categories/java基础/二维数组/"}],"tags":[{"name":"java","slug":"java","permalink":"http://39.99.158.50/tags/java/"},{"name":"二维数组","slug":"二维数组","permalink":"http://39.99.158.50/tags/二维数组/"}],"author":"echo"},{"title":"java中this关键字和super关键字的使用","slug":"java中this关键字和super关键字的使用","date":"2018-11-09T12:10:48.000Z","updated":"2020-05-05T14:45:01.193Z","comments":true,"path":"2018/11/09/java-zhong-this-guan-jian-zi-he-super-guan-jian-zi-de-shi-yong/","link":"","permalink":"http://39.99.158.50/2018/11/09/java-zhong-this-guan-jian-zi-he-super-guan-jian-zi-de-shi-yong/","excerpt":"","text":"[TOC] java中this关键字和super关键字的使用This关键字1.this可以用来修饰：属性，方法，构造器。2.this修饰属性和方法：this理解为当前对象或当前正在创建的对象 2.1在类的方法中，我们使用“this.属性”,”this.方法”的方式，调用当前对象属性或方法。但是一般选择省略 “this.”，特殊情况下，当属性和形参同名时，必须使用“this.变量”的方式表明此变量是属性，而非形参。2.2在类的构造器中，我们使用“this.属性”,”this.方法”的方式，调用当前正在创建的对象属性或方法。但是一般选择省略 “this.”，特殊情况下，当构造器的属性和形参同名时，必须使用“this.变量”的方式表明此变量是属性，而非形参。 3.this调用构造器①我们在类的构造器中，可以显式的使用“this（形参列表）”方式，调用本类中指定的其他构造器。②构造器不能通过“this（形参列表）”方式调用自己。③如果一个类中有n个构造器，则最多有n-1构造器使用了“this（形参列表）”④规定：“this（形参列表）”必须声明在当前构造器的首行⑤构造器内部，最多只能声明一个“this（形参列表）”，用来调用其他构造器。 super关键字的使用1.super理解为：父类的2.super可以用来调用：属性，方法，构造器3.super的使用3.1我们可以在子类的方法或构造器中。通过“super.属性”或“super.方法”的方式，式调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略“super.”3.2特殊情况：当子类和父类定义了同名属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用“super.属性”的方法，表明调用的是父类声明的属性。 3.3特殊情况：当子类重新了父类中的方法以后，我们想在子类中调用父类的被重写的方法，则必须显式的使用“super.属性”的方法，表明调用的是父类声明的方法 4.super调用构造器4.1我们可以在子类构造器中显式使用“super（形参列表）”的方式，调用父类中声明的指定的构造器4.2“super（形参列表）”的使用，必须声明在子类构造器的首行4.3我们在类构造器中，针对于“this.(形参列表)”或“super.形参列表”，只能二选一，不能同时出现4.4在构造器首行，没有显式的声明“this.(形参列表)”或“super.形参列表”则默认调用的是父类中的构造器（super）、4.5在类的多个构造器中，至少有一个类的构造器使用了“super.形参列表”，调用父类中的构造器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"面向对象","slug":"java基础/面向对象","permalink":"http://39.99.158.50/categories/java基础/面向对象/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/tags/java基础/"},{"name":"面向对象","slug":"面向对象","permalink":"http://39.99.158.50/tags/面向对象/"}],"author":"echo"},{"title":"方法的重载和重写","slug":"方法的重载（Overload）和重写（override_overwrite）","date":"2018-11-09T01:54:08.000Z","updated":"2020-04-14T07:39:37.360Z","comments":true,"path":"2018/11/09/fang-fa-de-chong-zai-overload-he-chong-xie-override-overwrite/","link":"","permalink":"http://39.99.158.50/2018/11/09/fang-fa-de-chong-zai-overload-he-chong-xie-override-overwrite/","excerpt":"","text":"方法的重載（overload） loading… 1.定義：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。简单的说就是“**同一个类中，方法名相同**！**方法的参数不同**” 2.举例如： //返回两个整数的和int add(int x,int y){return x+y;} //返回三个整数的和 int add(int x,int y,int z){return x+y+z;} 3.判断是否是重载 跟方法的权限修饰符，返回值类型，形参变量名，方法体都没关系 代码示例： public void getSum(int i,int j) { System.out.println(\"1\"); } public void getSum(double d1, double d2) { System.out.println(\"2\"); } public void getSum(String s,int i) { System.out.println(\"3\"); } 方法重写（override/overwrite）1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作 2.应用：重写以后，创建子类对象，通过子类对象调用子父类中同名同参数的方法时，实际调用的是子类中重写父类的方法。 3.重写的规定： 方法的声明：权限修饰符 返回值类型 方法名（形参列表） throws 异常类型{ //方法体 } 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法 ①子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同 ②子类重写的方法的权限修饰符不小于父类被重写方法的权限修饰符 &gt;特殊情况：子类不能重写父类中声明为private权限的方法 ③返回值类型： &gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void &gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类 &gt;父类被重写的方法的返回值类型是基本数据类型（比如int），则子类重写的方法的返回值类型必须是相同的基本数据类型（必须是int） ④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 注：实际开发中如果想重写方法，可以直接把父类中的方法声明，复制到子类写方法体就行 特别注意：子类和父类的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（静态的方法不能被重写） 代码示例:public class Person { String name; int age; public Person() { } public Person(String name,int age) { this.name = name; this.age = age; } public void eat() { System.out.println(\"吃飯\"); } /**/public class Student extends Person{ String major; public Student() { } public Student(String major) { this.major = major; } //对父类中的eat方法进行重写 public void eat() { System.out.println(\"多吃素菜！!\"); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"-java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"}],"tags":[{"name":"-java","slug":"java","permalink":"http://39.99.158.50/tags/java/"}]},{"title":"成员变量与局部变量的区别","slug":"成员变量与局部变量的区别","date":"2018-11-08T14:10:35.000Z","updated":"2020-05-05T14:45:01.201Z","comments":true,"path":"2018/11/08/cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie/","link":"","permalink":"http://39.99.158.50/2018/11/08/cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie/","excerpt":"","text":"[TOC] 属性（成员变量） VS 局部变量1、相同点: 1.1定义变量的格式：数据类型 变量名 = 变量值 1.2先声明，后使用 1.3变量都有其对应的作用域 2、不同点: 12345678910111213141516171819202122 2.1在类中声明的位置不同 属性直接定义在类的一对{}内 局部变量：声明在方法内，方法形参，代码块内，构造形参，构造器内的变量 2.2 默认初始化值的情况; 属性;类的属性，根据其类型都有默认初始化值。 整型（byte，short，int， long）： 0 浮点型（float，double）0.0 字符型（char）0或者（\\u0000） 布尔型（boolean）：false 引用数据类型（类，数组，接口）：null 局部变量没有初始化值。调用局部变量之前，一定要显示赋值 形参调用时，赋值就行 2.3在内存的加载位置 属性;加载到堆空间中（非static） 局部变量：加载到栈空间中 代码public static void main(String[] args) { User u1 = new User(); System.out.println(u1.name);//null System.out.println(u1.age);//0 System.out.println(u1.isMale);//false } 12345678910111213141516class User{/属性(或成员变量)String name;int age;boolean isMale;public void talk(String language) {//language:形参，也是局部变量 System.out.println(\"我们使用的是\"+language+\"进行交流\"); }public void eat() { String food = \"烙饼\";//局部变量 System.out.println(\"北方人喜欢吃\"+food);}} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"面向对象","slug":"java基础/面向对象","permalink":"http://39.99.158.50/categories/java基础/面向对象/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/tags/java基础/"},{"name":"面向对象","slug":"面向对象","permalink":"http://39.99.158.50/tags/面向对象/"}],"author":"echo"},{"title":"你好,Hexo","slug":"你好-Hexo","date":"2018-11-07T01:54:08.000Z","updated":"2020-04-14T07:37:36.987Z","comments":true,"path":"2018/11/07/ni-hao-hexo/","link":"","permalink":"http://39.99.158.50/2018/11/07/ni-hao-hexo/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"-hexo","slug":"hexo","permalink":"http://39.99.158.50/categories/hexo/"}],"tags":[{"name":"-博客","slug":"博客","permalink":"http://39.99.158.50/tags/博客/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-07T01:37:55.802Z","updated":"2020-04-14T07:37:49.104Z","comments":true,"path":"2018/11/07/hello-world/","link":"","permalink":"http://39.99.158.50/2018/11/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"-hexo","slug":"hexo","permalink":"http://39.99.158.50/categories/hexo/"}],"tags":[{"name":"-博客","slug":"博客","permalink":"http://39.99.158.50/tags/博客/"}]}],"categories":[{"name":"linux","slug":"linux","permalink":"http://39.99.158.50/categories/linux/"},{"name":"docker","slug":"linux/docker","permalink":"http://39.99.158.50/categories/linux/docker/"},{"name":"linux jdk","slug":"linux-jdk","permalink":"http://39.99.158.50/categories/linux-jdk/"},{"name":"-hexo -live2d -主题","slug":"hexo-live2d-主题","permalink":"http://39.99.158.50/categories/hexo-live2d-主题/"},{"name":"-live2d -主题","slug":"live2d-主题","permalink":"http://39.99.158.50/categories/live2d-主题/"},{"name":"hexo","slug":"hexo","permalink":"http://39.99.158.50/categories/hexo/"},{"name":"主题","slug":"hexo/主题","permalink":"http://39.99.158.50/categories/hexo/主题/"},{"name":"-hexo","slug":"hexo","permalink":"http://39.99.158.50/categories/hexo/"},{"name":"eclipse","slug":"eclipse","permalink":"http://39.99.158.50/categories/eclipse/"},{"name":"java","slug":"java","permalink":"http://39.99.158.50/categories/java/"},{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"算法","slug":"java基础/算法","permalink":"http://39.99.158.50/categories/java基础/算法/"},{"name":"数组","slug":"java基础/数组","permalink":"http://39.99.158.50/categories/java基础/数组/"},{"name":"二维数组","slug":"java基础/二维数组","permalink":"http://39.99.158.50/categories/java基础/二维数组/"},{"name":"面向对象","slug":"java基础/面向对象","permalink":"http://39.99.158.50/categories/java基础/面向对象/"},{"name":"-java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://39.99.158.50/tags/linux/"},{"name":"docker","slug":"docker","permalink":"http://39.99.158.50/tags/docker/"},{"name":"jdk","slug":"jdk","permalink":"http://39.99.158.50/tags/jdk/"},{"name":"live2d","slug":"live2d","permalink":"http://39.99.158.50/tags/live2d/"},{"name":"hexo","slug":"hexo","permalink":"http://39.99.158.50/tags/hexo/"},{"name":"-live2d -hexo","slug":"live2d-hexo","permalink":"http://39.99.158.50/tags/live2d-hexo/"},{"name":"主题","slug":"主题","permalink":"http://39.99.158.50/tags/主题/"},{"name":"-hexo","slug":"hexo","permalink":"http://39.99.158.50/tags/hexo/"},{"name":"eclipse","slug":"eclipse","permalink":"http://39.99.158.50/tags/eclipse/"},{"name":"java","slug":"java","permalink":"http://39.99.158.50/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://39.99.158.50/tags/算法/"},{"name":"数组","slug":"数组","permalink":"http://39.99.158.50/tags/数组/"},{"name":"二维数组","slug":"二维数组","permalink":"http://39.99.158.50/tags/二维数组/"},{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/tags/java基础/"},{"name":"面向对象","slug":"面向对象","permalink":"http://39.99.158.50/tags/面向对象/"},{"name":"-java","slug":"java","permalink":"http://39.99.158.50/tags/java/"},{"name":"-博客","slug":"博客","permalink":"http://39.99.158.50/tags/博客/"}]}