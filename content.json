{"meta":{"title":"不曾留得桃花影","subtitle":null,"description":null,"author":"echo","url":"http://39.99.158.50","root":"/"},"pages":[{"title":"about","date":"2020-04-14T05:54:18.000Z","updated":"2020-04-14T07:35:39.212Z","comments":true,"path":"about/index.html","permalink":"http://39.99.158.50/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-04-14T05:53:12.000Z","updated":"2020-04-14T05:53:12.899Z","comments":true,"path":"categories/index-1.html","permalink":"http://39.99.158.50/categories/index-1.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-04-14T05:51:58.000Z","updated":"2020-04-14T05:51:58.386Z","comments":true,"path":"tags/index-1.html","permalink":"http://39.99.158.50/tags/index-1.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2020-04-14T07:31:42.937Z","updated":"2020-04-14T07:31:42.937Z","comments":true,"path":"categories/index.html","permalink":"http://39.99.158.50/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-04-24T19:26:24.000Z","updated":"2020-04-24T19:26:24.219Z","comments":true,"path":"contact/index-1.html","permalink":"http://39.99.158.50/contact/index-1.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-04-24T14:16:03.000Z","updated":"2020-04-24T14:16:18.841Z","comments":true,"path":"friends/index.html","permalink":"http://39.99.158.50/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"Tags","date":"2020-04-14T07:36:01.558Z","updated":"2020-04-14T07:36:01.558Z","comments":false,"path":"tags/index.html","permalink":"http://39.99.158.50/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-04-24T14:15:06.000Z","updated":"2020-04-24T14:15:49.876Z","comments":true,"path":"contact/index.html","permalink":"http://39.99.158.50/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"如何设置docker服务器和容器的自启动","slug":"如何设置docker服务器和容器的自启动","date":"2019-06-27T14:29:57.000Z","updated":"2020-04-27T14:33:10.817Z","comments":true,"path":"2019/06/27/ru-he-she-zhi-docker-fu-wu-qi-he-rong-qi-de-zi-qi-dong/","link":"","permalink":"http://39.99.158.50/2019/06/27/ru-he-she-zhi-docker-fu-wu-qi-he-rong-qi-de-zi-qi-dong/","excerpt":"","text":"[TOC] docker设置自动启动一、docker服务设置自动启动查看已启动的服务 systemctl list-units –type=service 查看是否设置开机启动 systemctl list-unit-files | grep enable 设置开机启动 systemctl enable docker.service 关闭开机启动 systemctl disable docker.service 二、docker容器设置自动启动启动时加 --restart=always docker run -tid –name isaler_v0.0.11 -p 8081:8080 –restart=always` 12345Flag Descriptionno 不自动重启容器. (默认value)on-failure 容器发生error而退出(容器退出状态不为0)重启容器unless-stopped 在容器已经stop掉或Docker stoped/restarted的时候才重启容器always 在容器已经stop掉或Docker stoped/restarted的时候才重启容器 如果已经过运行的项目 如果已经启动的项目，则使用update更新： docker update --restart=always isaler_v0.0.11 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"linux","slug":"linux","permalink":"http://39.99.158.50/categories/linux/"},{"name":"docker","slug":"linux/docker","permalink":"http://39.99.158.50/categories/linux/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://39.99.158.50/tags/docker/"},{"name":"linux","slug":"linux","permalink":"http://39.99.158.50/tags/linux/"}],"author":"echo"},{"title":"如何在linux上装jdk1.8并配置环境","slug":"如何在linux上装jdk1-8并配置环境","date":"2019-06-27T13:13:17.000Z","updated":"2020-04-27T14:29:27.641Z","comments":true,"path":"2019/06/27/ru-he-zai-linux-shang-zhuang-jdk1-8-bing-pei-zhi-huan-jing/","link":"","permalink":"http://39.99.158.50/2019/06/27/ru-he-zai-linux-shang-zhuang-jdk1-8-bing-pei-zhi-huan-jing/","excerpt":"","text":"[TOC] 本文主要介绍的是如何是Linux环境下安装JDK的，因为Linux环境下，很多时候也离不开Java的，下面笔者就和大家一起分享如何jdk1.8的过程吧。 1、安装环境操作系统：CentOS7 64位 jdk版本：1.8 工具：Xshell6、Xftp6 说明：Xshell6用于远程连接linux，Xftp用于上传资源到linux，两款软件是配合使用的可自行百度个人使用是免费的 2、安装步骤第一步：下载Linux环境下的jdk1.8安装包 点击移步下载 第二步：把下载安装包，上传至服务器中。Xftp的使用方法就不讲了 ，自信百度 第三步：解压安装包 将我们下载好的安装包上传至服务器，进行解压，使用Xshell远程操作 解压命令：tar -zxvf [里面为你的jdk压缩包名] 解压完成后，可以在当前目录下看到一个名字为jdk1.8.0_171的文件 3、配置环境变量配置环境变量的配置文件vim /etc/profile vim /etc/profile 拖到文件最后加上如下字符 JAVA_HOME=/opt/jdk1.8.0_171PATH=/opt/jdk1.8.0_171/bin:$PATHexport JAVA_HOME PATH 接着，按ESC键，然后:wq保存退出，输入reboot使服务器重启使jdk环境变量生效 查看jdk版本 输入 java -version或javac -version 出现版本号就代表安装成功了 如果没有就去看看profile里是不是配置错了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"linux jdk","slug":"linux-jdk","permalink":"http://39.99.158.50/categories/linux-jdk/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://39.99.158.50/tags/linux/"},{"name":"jdk","slug":"jdk","permalink":"http://39.99.158.50/tags/jdk/"}],"author":"echo"},{"title":"Hexo博客主题美化之新增看板娘","slug":"Hexo博客主题美化之新增看板娘","date":"2019-06-26T13:31:55.000Z","updated":"2020-04-26T14:12:54.628Z","comments":true,"path":"2019/06/26/hexo-bo-ke-zhu-ti-mei-hua-zhi-xin-zeng-kan-ban-niang/","link":"","permalink":"http://39.99.158.50/2019/06/26/hexo-bo-ke-zhu-ti-mei-hua-zhi-xin-zeng-kan-ban-niang/","excerpt":"","text":"Hexo博客主题美化之新增看板娘效果 教程①首先检查博客主目录下面的 package.json里是否有\"hexo-helper-live2d\": \"^3.0.3\",依赖，有的话可以先卸载 使用命令：npm uninstall hexo-helper-live2d ②安装模块，如下： npm install --save hexo-helper-live2d 注意：命令都是在你的博客主目录执行！！！！ 安装完成之后在package.json会看到安装的model 此时再去 node_moduels目录下，可以看到有如下文件夹，这些都是动画主配置 ③输入以下命令，下载相应的模型，将 packagename 更换成模型名称即可，更多模型选择请点击此处 $ npm install packagename 例如：npm install live2d-widget-model-haruto ④打开博客根目录下的 _config.yml 文件，添加如下代码： 1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-haruto #模型名称 就是你下的 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: false #是否在手机端显示 设置好过后我们就拥有了一个卡通人物 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"-hexo -live2d -主题","slug":"hexo-live2d-主题","permalink":"http://39.99.158.50/categories/hexo-live2d-主题/"}],"tags":[{"name":"live2d","slug":"live2d","permalink":"http://39.99.158.50/tags/live2d/"},{"name":"hexo","slug":"hexo","permalink":"http://39.99.158.50/tags/hexo/"}],"author":"echo"},{"title":"live2d看板娘一览图","slug":"live2d看板娘一览图","date":"2019-06-26T13:04:11.000Z","updated":"2020-04-26T15:02:05.099Z","comments":true,"path":"2019/06/26/live2d-kan-ban-niang-yi-lan-tu/","link":"","permalink":"http://39.99.158.50/2019/06/26/live2d-kan-ban-niang-yi-lan-tu/","excerpt":"","text":"live2d看板娘一览图模型下载地址：点击移步搭建教程：点击移步模型预览live2d-widget-model-chitose live2d-widget-model-epsilon2_1 live2d-widget-model-gf live2d-widget-model-izumi live2d-widget-model-koharu live2d-widget-model-miku live2d-widget-model-ni-j live2d-widget-model-nico live2d-widget-model-nietzschelive2d-widget-model-nipsilon live2d-widget-model-nito live2d-widget-model-shizuku live2d-widget-model-tororo live2d-widget-model-tsumiki live2d-widget-model-unitychan live2d-widget-model-wanko live2d-widget-model-z16 live2d-widget-model-hibiki live2d-widget-model-hijiki document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"-live2d -主题","slug":"live2d-主题","permalink":"http://39.99.158.50/categories/live2d-主题/"}],"tags":[{"name":"-live2d -hexo","slug":"live2d-hexo","permalink":"http://39.99.158.50/tags/live2d-hexo/"}],"author":"echo"},{"title":"使用Hexo为博客更换自己喜欢的主题","slug":"使用Hexo为博客更换自己喜欢的主题","date":"2019-06-26T11:58:05.000Z","updated":"2020-04-26T13:58:07.792Z","comments":true,"path":"2019/06/26/shi-yong-hexo-wei-bo-ke-geng-huan-zi-ji-xi-huan-de-zhu-ti/","link":"","permalink":"http://39.99.158.50/2019/06/26/shi-yong-hexo-wei-bo-ke-geng-huan-zi-ji-xi-huan-de-zhu-ti/","excerpt":"","text":"Hexo为博客更换自己喜欢的主题博客也搭建好了，文章也会写了,但是默认主题巨丑怎么办，那我们就自定义自己喜欢的主题 点击此处进入 Hexo 官网的主题专栏 我们要做的就是把主题克隆过来，在此我们以主题 Nexmoe 为例，点进去我们就可以看见该主题作者的博客，点击Clone or download 复制https地址，在博客根目录的themes（比如我的D:\\blog\\themes）打开Git命令行输入 git clone https://github.com/theme-nexmoe/hexo-theme-nexmoe.git 待下载完成后即可在 themes 目录下生成 hexo-theme-nexmoe 文件夹，然后打开 blog 文件夹下的配置文件 _config.yml ，找到关键字 theme，修改参数为：hexo-theme-nexmoe（其他主题修改成相应名称即可），再次注意冒号后面有一个空格！ 返回 Hexo 目录，右键 Git Bash Here ，输入以下命令开始部署主题： 123hexo cleanhexo ghexo s 此时打开浏览器，访问 http://localhost:4000/ 就可看见我们的主题已经更换了，如果感觉效果满意，我们就可以把它部署到Github上了 hexo d 此时访问自己的博客即可看见更换后的主题，但我们仍然需要对主题的相关配置进行修改，比如网站标题，图标等等具体配置请移步《快速开始》 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"hexo","slug":"hexo","permalink":"http://39.99.158.50/categories/hexo/"},{"name":"主题","slug":"hexo/主题","permalink":"http://39.99.158.50/categories/hexo/主题/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://39.99.158.50/tags/hexo/"},{"name":"主题","slug":"主题","permalink":"http://39.99.158.50/tags/主题/"}],"author":"echo"},{"title":"使用Hexo和github搭建自己的博客超详细奶妈级别教程","slug":"使用Hexo和github搭建自己的博客超详细奶妈级别教程","date":"2019-06-25T10:12:01.000Z","updated":"2020-04-26T12:57:47.534Z","comments":true,"path":"2019/06/25/shi-yong-hexo-he-github-da-jian-zi-ji-de-bo-ke-chao-xiang-xi-nai-ma-ji-bie-jiao-cheng/","link":"","permalink":"http://39.99.158.50/2019/06/25/shi-yong-hexo-he-github-da-jian-zi-ji-de-bo-ke-chao-xiang-xi-nai-ma-ji-bie-jiao-cheng/","excerpt":"","text":"[TOC] 入门简介博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。今天我们学习的是Hexo+Github的方式。 Github Pages可以被认为是用户编写的、托管在github上的静态网页。使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 环境安装Git安装百度搜索git，点击进入 点击Downloads 接着 不知道的朋友可以鼠标右击此电脑（或我的电脑）点属性就可以看到了! 然后无限下一步安装就行了（注意安装目录不要有中文字符和空格） git安装好在任何一个文件夹右击鼠标后出现以下选项，证明Git安装好了 安装Nodejs百度搜索nodejs或直接点击此处进入下载官网 然后无限下一步安装就行 检验Git是否安装成功在桌面右键鼠标，可以看到菜单里多了 Git GUI Here 和 Git Bash Here两个选项，第一个是图形界面的Git操作，另一个是命令行，选择第二个 123456输入``git --version` `node -v `npm -v` 如果出现版本号则表示安装成功 安装Hexo新建一个文件夹如：我的文件夹为：D\\blog），博客相关文件将储存在此文件夹下，在该文件夹下右键鼠标，点击 Git Bash Here，输入以下 npm 命令即可安装，第一个命令表示安装 hexo，第二个命令表示安装 hexo 部署到 git page 的 deployer，如图所示即为安装成功 npm install hexo-cli -gnpm install hexo-deployer-git --save Hexo配置在创的文件夹下右键鼠标，点击 Git Bash Here，输入以下命令，如图所示则安装成功 hexo init Hexo安装完成后，将在blog目录中新建所需要的文件，如下 Hexo使用命令1234567hexo sever ： #启动博客程序``hexo clean： #用来清理缓存文件``hexo g ： #生成文件``hexo s ： #运行本地服务器``hexo d ： #上传到服务器 出现如下界面就可以访问博客啦，在浏览器地址栏输入http://localhost:4000就可以访问了 访问页面 将博客部署到Github上注册Github账户点击此处访问github官网，点击 Sign Up 注册账户 登录后点击! ​ 配置SSH密钥只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步，在你第一次新建的文件夹里面（如：我的文件夹为：D\\blog） Git Bash Here 输入以下命令： 1234567891011121314151617181920212223 `$ ssh-keygen -t rsa -C \"your email@example.com\"` `//引号里面填写你的邮箱地址`之后会出现： `Generating public/private rsa key pair.` Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): `//到这里可以直接回车将密钥按默认文件进行存储`然后会出现： `Enter passphrase (empty for no passphrase):` //这里是要你输入密码，其实不需要输什么密码，直接回车就行 `Enter same passphrase again:` 接下来屏幕会显示： `Your identification has been saved in /c/Users/you/.ssh/id_rsa.` Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 这里是各种字母数字组成的字符串，结尾是你的邮箱 The key's randomart image is: `这里也是各种字母数字符号组成的字符串` 运行以下命令，将公钥的内容复制到系统粘贴板上也可以去C盘的用户目录下 比如我的C:\\Users\\liuxin\\.ssh找到id_rsa.pub打开复制 $ clip &lt; ~/.ssh/id_rsa.pub GitHub 账户中添加你的公钥①登陆 GitHub，进入 Settings： 测试输入以下命令：注意：git@github.com不要做任何更改！ ssh -T git@github.com 之后会显示： 输入 yes 后会显示： 此时表示设置正确 配置Git个人信息Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理 git config --global user.name \"此处填你的用户名\"git config --global user.email \"此处填你的邮箱\" 到此为止 SSH Key 配置成功，本机已成功连接到 Github 将本地的 Hexo 文件更新到 Github 的库中登录 Github 打开自己的项目 your name.github.io 鼠标移到 Clone or download 按钮，选择 Use SSH 打开你创建的文件夹（如：D:\\blog）打开该文件夹下的 _config.yml 文件,我的是部署过得所以文件比你们的多 然后在D/blog目录下点击 Git Bash Here输入以下命令 hexo g hexo d 或直接执行 hexo g -d 执行完之后会让你输入你的 Github 的账号和密码，如果此时报以下错误，说明你的 deployer 没有安装成功 ERROR Deployer not found: git 需要执行以下命令再安装一次： npm install hexo-deployer-git --save 再执行 hexo g -d，你的博客就会部署到 Github 上了 访问博客进入你的项目点击settings,选择Options，往下翻找到GitHub Pages里面就是你的博客地址，现在每个人都可以通过此链接访问你的博客了！ Hexo博客发表文章新建一个空文章输入以下命令，会在项目D:\\blog\\source_posts中生成 文章标题.md 文件，文章标题根据需要命名 hexo n \"文章标题\" 也可以直接在D:\\blog\\source_posts目录下右键鼠标新建文本文档，改后缀为 .md 即可，这种方法比较方便 用编辑器编写文章:推荐几款好用的md编辑器md 全称 Markdown 1.Typora 2.MarkdownPad2 3.BookPad 4.小书匠 5.Sublime Text 3 文章标题，标签，分类，封面图片，摘要等，可以在 Front-matter 里面配置（Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，官方文档：https://hexo.io/zh-cn/docs/front-matter ），举个例子： layout: 页面布局（配合主题文档使用）title: 文章名称date: 文章日期comments: 文章是否开启评论photos: 文章封面图（仅部分主题支持）tags: 文章标签一 文章标签二categories: 文章分类description: 文章描述，即要在首页显示的摘要（仅部分主题支持） 这里是摘要 &lt;!-- more --&gt; 这里是正文 注意：description 和 &lt;!-- more --&gt; 方式显示摘要二选一即可，部分主题不支持description，每个配置英文冒号后面要空一格，不同主题配置有所差异，具体要参考主题文档 当我们用编辑器写好文章后，可以使用以下命令将其推送到服务器上 hexo clean hexo g hexo d 现在访问你的博客就可以看见写好的文章啦！ 好了现在就可以邀请你朋友一起看你的个人博客啦！！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"-hexo","slug":"hexo","permalink":"http://39.99.158.50/categories/hexo/"}],"tags":[{"name":"-hexo","slug":"hexo","permalink":"http://39.99.158.50/tags/hexo/"}],"author":"echo"},{"title":"Eclipse怎么设置类头信息的方法","slug":"Eclipse怎么设置类头信息的方法","date":"2019-05-05T14:10:16.000Z","updated":"2020-05-05T14:45:01.191Z","comments":true,"path":"2019/05/05/eclipse-zen-me-she-zhi-lei-tou-xin-xi-de-fang-fa/","link":"","permalink":"http://39.99.158.50/2019/05/05/eclipse-zen-me-she-zhi-lei-tou-xin-xi-de-fang-fa/","excerpt":"","text":"首先打开Eclipse配置选项：Window-&gt;Preference-&gt;Java-&gt;Code Style-&gt;Code Template 下面是我列举的几个常用的模板1、Files /** @Title: ${file_name}@Package ${package_name}@Description: ${todo}(用一句话描述该文件做什么)@author （这里是作者，不写默认是你电脑的用户名，可以自定义）@date ${date}*/ 2、Types /** @Description: ${todo}(这里用一句话描述这个类的作用)@CopyRightInformation : XXX(公司名称)@ApplicationName: ${project_name}@Title: ${file_name}@author （这里是作者，不写默认是你电脑的用户名，可以自定义）@date: ${date} ${time}${tags}*/3、Constructors /** ${tags}*/4、Methods /** @Title: ${enclosing_method}@Description: ${todo}(这里用一句话描述这个方法的作用)@author: （这里是作者，不写默认是你电脑的用户名，可以自定义）@date: ${date} ${time}@param ${tags} 参数@return ${return_type} 返回类型@throws*/5、Overriding methods /** Title: ${enclosing_method} Description: ${tags}${see_to_overridden}*/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"eclipse","slug":"eclipse","permalink":"http://39.99.158.50/categories/eclipse/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://39.99.158.50/tags/eclipse/"}],"author":"echo"},{"title":"水仙花束","slug":"水仙花束","date":"2018-11-10T14:10:03.000Z","updated":"2020-05-05T14:45:01.203Z","comments":true,"path":"2018/11/10/shui-xian-hua-shu/","link":"","permalink":"http://39.99.158.50/2018/11/10/shui-xian-hua-shu/","excerpt":"","text":"简介水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身（例如：1^3 + 5^3+ 3^3 = 153）。 代码123456789101112131415161718192021public class waterFlowerNum { public static void waterFlower() { // 求出个、十、百的数字 for(int i=100;i&lt;1000;i++) { int g = i/1%10; int s = i/10%10; int b = i/100; if(g*g*g + s*s*s + b*b*b==i) { System.out.print(i + \" \"); } } } public static void main(String[] args) { waterFlower(); } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java","slug":"java","permalink":"http://39.99.158.50/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://39.99.158.50/tags/java/"}],"author":"echo"},{"title":"快速排序","slug":"快速排序","date":"2018-11-10T05:54:08.000Z","updated":"2020-05-05T14:45:01.199Z","comments":true,"path":"2018/11/10/kuai-su-pai-xu/","link":"","permalink":"http://39.99.158.50/2018/11/10/kuai-su-pai-xu/","excerpt":"","text":"[TOC] 快速排序( ( ( ( 分区交换排序) ) ) )快速排序（Quick Sorting）是迄今为止所有内排序算法中速度最快的一种。它的 基本思想是：任取待排序序列中的某个元素作为标准（ 也称为支点、界点， 一般取第一个元素），通过一次划分，将待排元素分为左右两个子序列，左子序列元素的排序码均小于基准元素的排序码，右子序列的排序码则大于或等于基准元素的排序码，然后分别对两个子序列继续进行划分，直至每一个序列只有一个元素为止。最后得到的序列便是有序序列。 一次划分的具体过程​ 1．low指向待划分区域首元素，high指向待划分区域尾元素;​ 2．R[0]=R[low] (为了减少数据的移动,将作为标准的元素暂存到R[0]中，最后再放入最终位置) ; high从后往前移动直到R[high].key&lt;R[0].key; R[low]=R[high], low++; low从前往后移动直到R[low].key&gt;=R[0].key; R[high]=R[low], high–; goto 3; 直到low==high时，R[low]=R[0] (即将作为标准的元素放到其最终位置) 。概括地说, 一次划分就是从表的两端交替地向中间进行扫描,将小的放到左边, 大的放到右边, 作为标准的元素放到中间。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package test;public class QuickSort { public static void main(String[] args) { int[] a = {12,20,5,16,15,1,30,45,23,9,4,4}; int min = 0; int max = a.length-1; sort(a, min, max); for (int i : a) { System.out.println(i); } } /* * 首先需要一个数组存放所有的数据 * 定一个开始位置和一个结束为止 * 选择一个数作为准基数 */ public static void sort(int a[],int min,int max) { int key=a[min];//准基数 int start=min; //开始位置 int end =max;//结束位置 while(end&gt;start) { //循环条件是否数值交叉 //从后开始往前查找 while(end&gt;start&amp;&amp;a[end]&gt;=key) { //如果找到的值大于基数值，那么继续往下找，end-- end--; } //如果找到的值小于基数值，那么进行值交换 if(a[end]&lt;key) { int i=a[end]; a[end]=a[start]; a[start]=i; } //从前往后找 while(end&gt;start&amp;&amp;a[start]&lt;=key) { //如果找到的值小于基数值，那么继续往下找，start++ start++; } //如果找到的值大于基数值，那么进行值交换 if(a[start]&gt;key) { int i=a[start]; a[start]=a[end]; a[end]=i; } } //这部分的数据都是小于准基数，通过递归在进行一趟快排 if(start&gt;min) { sort(a, min, start-1); //开始位置为第一位，结束位置为关键索引-1 } if(end&lt;max) { sort(a, end+1, max); //开始位置为关键索引+1，结束位置最后一位 } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"算法","slug":"java基础/算法","permalink":"http://39.99.158.50/categories/java基础/算法/"}],"tags":[{"name":"java","slug":"java","permalink":"http://39.99.158.50/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://39.99.158.50/tags/算法/"}],"author":"echo"},{"title":"简单的冒泡排序","slug":"简单的冒泡排序","date":"2018-11-10T03:54:08.000Z","updated":"2020-05-05T14:45:01.204Z","comments":true,"path":"2018/11/10/jian-dan-de-mou-pao-pai-xu/","link":"","permalink":"http://39.99.158.50/2018/11/10/jian-dan-de-mou-pao-pai-xu/","excerpt":"","text":"[TOC] 冒泡排序介绍：冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。 排序思想：比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。快速 排序 介绍：快速排序通常明显比同为O(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。快速排序（Quick Sort）由图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算法中速度最快的一种。冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为O(nlog(n))。 演示 代码1234567891011121314151617181920212223242526public class BubbleSortTest {public static void main(String[] args) { int[] arr = new int[]{43,42,56,75,64,58,97,86}; //冒泡排序 第一大轮 //八个元素比七轮 所以 arr.length - 1 for (int i = 0; i &lt; arr.length - 1; i++) { // 当 i=1时第二大轮 arr.length - 1 还要少一个 for (int j = 0; j &lt; arr.length - 1 - i; j++) { //当前一个比后一个数大时交换 if (arr[j] &gt; arr[j + 1 ]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } //遍历 for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \"\\t \"); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"算法","slug":"java基础/算法","permalink":"http://39.99.158.50/categories/java基础/算法/"}],"tags":[{"name":"java","slug":"java","permalink":"http://39.99.158.50/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://39.99.158.50/tags/算法/"}],"author":"echo"},{"title":"java中数组的复制、反转、查找操作(线性查找、二分法查找)","slug":"java中数组的复制、反转、查找操作-线性查找、二分法查找","date":"2018-11-10T02:54:08.000Z","updated":"2020-05-05T14:45:01.196Z","comments":true,"path":"2018/11/10/java-zhong-shu-zu-de-fu-zhi-fan-zhuan-cha-zhao-cao-zuo-xian-xing-cha-zhao-er-fen-fa-cha-zhao/","link":"","permalink":"http://39.99.158.50/2018/11/10/java-zhong-shu-zu-de-fu-zhi-fan-zhuan-cha-zhao-cao-zuo-xian-xing-cha-zhao-er-fen-fa-cha-zhao/","excerpt":"","text":"[TOC] 二分法查找的原理： 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void main(String[] args) {String[] arr = new String[] {“GG”,“MM”,“JJ”,“DD”,“BB”,“AA”}; //数组的复制(区别于数组的赋值：arr1 = arr) String[] arr1 = new String[arr.length]; for (int i = 0; i &lt; arr1.length; i++) { arr1[i] = arr[i]; } //数组的反转 for (int i = 0,j = arr.length -1;i &lt; j; i++,j--) { String temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } //遍历 for (int i = 0; i &lt; arr1.length; i++) { System.out.print(arr[i] + \"\\t\"); } System.out.println(); //数组的查找 （二分法查找） //前提 ：数组必须是有序的 int[] arr2 = new int[] {-90,-78,-77,0,123,345,657,875,899,990,999}; int dest = 345; int head = 0;//初始首索引值 int end = arr2.length -1;//初始的末索引 boolean isFlag = true; while(head &lt;= end) { int mid = (head + end) / 2; //得到索引的中间值 if (dest == arr2[mid]) { System.out.println(\"找到了指定的元素，位置为：\"+mid); isFlag = false; break; }else if (arr2[mid] &gt; dest) { end = mid -1; }else {//arr2{mid} &lt;dest head = mid + 1; } } if (isFlag) { System.out.println(\"很遗憾没有找到啦！\"); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"数组","slug":"java基础/数组","permalink":"http://39.99.158.50/categories/java基础/数组/"}],"tags":[{"name":"java","slug":"java","permalink":"http://39.99.158.50/tags/java/"},{"name":"数组","slug":"数组","permalink":"http://39.99.158.50/tags/数组/"}],"author":"echo"},{"title":"java实现杨辉三角","slug":"java实现杨辉三角","date":"2018-11-10T01:54:08.000Z","updated":"2020-05-05T14:45:01.197Z","comments":true,"path":"2018/11/10/java-shi-xian-yang-hui-san-jiao/","link":"","permalink":"http://39.99.158.50/2018/11/10/java-shi-xian-yang-hui-san-jiao/","excerpt":"","text":"使用二维数组打印一个 10 行杨辉三角。* 【提示】 1. 第一行有 1 个元素, 第 n 行有 n 个元素 2. 每一行的第一个元素和最后一个元素都是 1 3. 从第三行开始, 对于非第一个元素和最后一个元 素的元素。即：yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j]; 效果图： 代码： 12345678910111213141516171819202122232425262728293031public class YangHui {``public static void main(String[] args) {``` //1.声明并初始化二维数组 int[][] yanghui = new int[10][]; //2.给数组的元素赋值 for (int i = 0; i &lt; yanghui.length; i++) { yanghui[i] = new int[i+1];//第一行有1个元素 第二行有2个元素 //2.1给首末元素赋值 yanghui[i][0] = yanghui[i][i] = 1; //2.2给每行的非首末元素赋值 for (int j = 1; j &lt; yanghui[i].length - 1; j++) { yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j]; } } //3.遍历二维数组 for (int i = 0; i &lt; yanghui.length; i++) { for (int j = 0; j &lt; yanghui[i].length; j++) { System.out.print(yanghui[i][j] + \" \"); } System.out.println(); }`}` document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"二维数组","slug":"java基础/二维数组","permalink":"http://39.99.158.50/categories/java基础/二维数组/"}],"tags":[{"name":"java","slug":"java","permalink":"http://39.99.158.50/tags/java/"},{"name":"二维数组","slug":"二维数组","permalink":"http://39.99.158.50/tags/二维数组/"}],"author":"echo"},{"title":"java中this关键字和super关键字的使用","slug":"java中this关键字和super关键字的使用","date":"2018-11-09T12:10:48.000Z","updated":"2020-05-05T14:45:01.193Z","comments":true,"path":"2018/11/09/java-zhong-this-guan-jian-zi-he-super-guan-jian-zi-de-shi-yong/","link":"","permalink":"http://39.99.158.50/2018/11/09/java-zhong-this-guan-jian-zi-he-super-guan-jian-zi-de-shi-yong/","excerpt":"","text":"[TOC] java中this关键字和super关键字的使用This关键字1.this可以用来修饰：属性，方法，构造器。2.this修饰属性和方法：this理解为当前对象或当前正在创建的对象 2.1在类的方法中，我们使用“this.属性”,”this.方法”的方式，调用当前对象属性或方法。但是一般选择省略 “this.”，特殊情况下，当属性和形参同名时，必须使用“this.变量”的方式表明此变量是属性，而非形参。2.2在类的构造器中，我们使用“this.属性”,”this.方法”的方式，调用当前正在创建的对象属性或方法。但是一般选择省略 “this.”，特殊情况下，当构造器的属性和形参同名时，必须使用“this.变量”的方式表明此变量是属性，而非形参。 3.this调用构造器①我们在类的构造器中，可以显式的使用“this（形参列表）”方式，调用本类中指定的其他构造器。②构造器不能通过“this（形参列表）”方式调用自己。③如果一个类中有n个构造器，则最多有n-1构造器使用了“this（形参列表）”④规定：“this（形参列表）”必须声明在当前构造器的首行⑤构造器内部，最多只能声明一个“this（形参列表）”，用来调用其他构造器。 super关键字的使用1.super理解为：父类的2.super可以用来调用：属性，方法，构造器3.super的使用3.1我们可以在子类的方法或构造器中。通过“super.属性”或“super.方法”的方式，式调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略“super.”3.2特殊情况：当子类和父类定义了同名属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用“super.属性”的方法，表明调用的是父类声明的属性。 3.3特殊情况：当子类重新了父类中的方法以后，我们想在子类中调用父类的被重写的方法，则必须显式的使用“super.属性”的方法，表明调用的是父类声明的方法 4.super调用构造器4.1我们可以在子类构造器中显式使用“super（形参列表）”的方式，调用父类中声明的指定的构造器4.2“super（形参列表）”的使用，必须声明在子类构造器的首行4.3我们在类构造器中，针对于“this.(形参列表)”或“super.形参列表”，只能二选一，不能同时出现4.4在构造器首行，没有显式的声明“this.(形参列表)”或“super.形参列表”则默认调用的是父类中的构造器（super）、4.5在类的多个构造器中，至少有一个类的构造器使用了“super.形参列表”，调用父类中的构造器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"面向对象","slug":"java基础/面向对象","permalink":"http://39.99.158.50/categories/java基础/面向对象/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/tags/java基础/"},{"name":"面向对象","slug":"面向对象","permalink":"http://39.99.158.50/tags/面向对象/"}],"author":"echo"},{"title":"方法的重载和重写","slug":"方法的重载（Overload）和重写（override_overwrite）","date":"2018-11-09T01:54:08.000Z","updated":"2020-04-14T07:39:37.360Z","comments":true,"path":"2018/11/09/fang-fa-de-chong-zai-overload-he-chong-xie-override-overwrite/","link":"","permalink":"http://39.99.158.50/2018/11/09/fang-fa-de-chong-zai-overload-he-chong-xie-override-overwrite/","excerpt":"","text":"方法的重載（overload） loading… 1.定義：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。简单的说就是“**同一个类中，方法名相同**！**方法的参数不同**” 2.举例如： //返回两个整数的和int add(int x,int y){return x+y;} //返回三个整数的和 int add(int x,int y,int z){return x+y+z;} 3.判断是否是重载 跟方法的权限修饰符，返回值类型，形参变量名，方法体都没关系 代码示例： public void getSum(int i,int j) { System.out.println(\"1\"); } public void getSum(double d1, double d2) { System.out.println(\"2\"); } public void getSum(String s,int i) { System.out.println(\"3\"); } 方法重写（override/overwrite）1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作 2.应用：重写以后，创建子类对象，通过子类对象调用子父类中同名同参数的方法时，实际调用的是子类中重写父类的方法。 3.重写的规定： 方法的声明：权限修饰符 返回值类型 方法名（形参列表） throws 异常类型{ //方法体 } 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法 ①子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同 ②子类重写的方法的权限修饰符不小于父类被重写方法的权限修饰符 &gt;特殊情况：子类不能重写父类中声明为private权限的方法 ③返回值类型： &gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void &gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类 &gt;父类被重写的方法的返回值类型是基本数据类型（比如int），则子类重写的方法的返回值类型必须是相同的基本数据类型（必须是int） ④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 注：实际开发中如果想重写方法，可以直接把父类中的方法声明，复制到子类写方法体就行 特别注意：子类和父类的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（静态的方法不能被重写） 代码示例:public class Person { String name; int age; public Person() { } public Person(String name,int age) { this.name = name; this.age = age; } public void eat() { System.out.println(\"吃飯\"); } /**/public class Student extends Person{ String major; public Student() { } public Student(String major) { this.major = major; } //对父类中的eat方法进行重写 public void eat() { System.out.println(\"多吃素菜！!\"); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"-java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"}],"tags":[{"name":"-java","slug":"java","permalink":"http://39.99.158.50/tags/java/"}]},{"title":"成员变量与局部变量的区别","slug":"成员变量与局部变量的区别","date":"2018-11-08T14:10:35.000Z","updated":"2020-05-05T14:45:01.201Z","comments":true,"path":"2018/11/08/cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie/","link":"","permalink":"http://39.99.158.50/2018/11/08/cheng-yuan-bian-liang-yu-ju-bu-bian-liang-de-qu-bie/","excerpt":"","text":"[TOC] 属性（成员变量） VS 局部变量1、相同点: 1.1定义变量的格式：数据类型 变量名 = 变量值 1.2先声明，后使用 1.3变量都有其对应的作用域 2、不同点: 12345678910111213141516171819202122 2.1在类中声明的位置不同 属性直接定义在类的一对{}内 局部变量：声明在方法内，方法形参，代码块内，构造形参，构造器内的变量 2.2 默认初始化值的情况; 属性;类的属性，根据其类型都有默认初始化值。 整型（byte，short，int， long）： 0 浮点型（float，double）0.0 字符型（char）0或者（\\u0000） 布尔型（boolean）：false 引用数据类型（类，数组，接口）：null 局部变量没有初始化值。调用局部变量之前，一定要显示赋值 形参调用时，赋值就行 2.3在内存的加载位置 属性;加载到堆空间中（非static） 局部变量：加载到栈空间中 代码public static void main(String[] args) { User u1 = new User(); System.out.println(u1.name);//null System.out.println(u1.age);//0 System.out.println(u1.isMale);//false } 12345678910111213141516class User{/属性(或成员变量)String name;int age;boolean isMale;public void talk(String language) {//language:形参，也是局部变量 System.out.println(\"我们使用的是\"+language+\"进行交流\"); }public void eat() { String food = \"烙饼\";//局部变量 System.out.println(\"北方人喜欢吃\"+food);}} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"面向对象","slug":"java基础/面向对象","permalink":"http://39.99.158.50/categories/java基础/面向对象/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/tags/java基础/"},{"name":"面向对象","slug":"面向对象","permalink":"http://39.99.158.50/tags/面向对象/"}],"author":"echo"},{"title":"你好,Hexo","slug":"你好-Hexo","date":"2018-11-07T01:54:08.000Z","updated":"2020-04-14T07:37:36.987Z","comments":true,"path":"2018/11/07/ni-hao-hexo/","link":"","permalink":"http://39.99.158.50/2018/11/07/ni-hao-hexo/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"-hexo","slug":"hexo","permalink":"http://39.99.158.50/categories/hexo/"}],"tags":[{"name":"-博客","slug":"博客","permalink":"http://39.99.158.50/tags/博客/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-07T01:37:55.802Z","updated":"2020-04-14T07:37:49.104Z","comments":true,"path":"2018/11/07/hello-world/","link":"","permalink":"http://39.99.158.50/2018/11/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"-hexo","slug":"hexo","permalink":"http://39.99.158.50/categories/hexo/"}],"tags":[{"name":"-博客","slug":"博客","permalink":"http://39.99.158.50/tags/博客/"}]}],"categories":[{"name":"linux","slug":"linux","permalink":"http://39.99.158.50/categories/linux/"},{"name":"docker","slug":"linux/docker","permalink":"http://39.99.158.50/categories/linux/docker/"},{"name":"linux jdk","slug":"linux-jdk","permalink":"http://39.99.158.50/categories/linux-jdk/"},{"name":"-hexo -live2d -主题","slug":"hexo-live2d-主题","permalink":"http://39.99.158.50/categories/hexo-live2d-主题/"},{"name":"-live2d -主题","slug":"live2d-主题","permalink":"http://39.99.158.50/categories/live2d-主题/"},{"name":"hexo","slug":"hexo","permalink":"http://39.99.158.50/categories/hexo/"},{"name":"主题","slug":"hexo/主题","permalink":"http://39.99.158.50/categories/hexo/主题/"},{"name":"-hexo","slug":"hexo","permalink":"http://39.99.158.50/categories/hexo/"},{"name":"eclipse","slug":"eclipse","permalink":"http://39.99.158.50/categories/eclipse/"},{"name":"java","slug":"java","permalink":"http://39.99.158.50/categories/java/"},{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"},{"name":"算法","slug":"java基础/算法","permalink":"http://39.99.158.50/categories/java基础/算法/"},{"name":"数组","slug":"java基础/数组","permalink":"http://39.99.158.50/categories/java基础/数组/"},{"name":"二维数组","slug":"java基础/二维数组","permalink":"http://39.99.158.50/categories/java基础/二维数组/"},{"name":"面向对象","slug":"java基础/面向对象","permalink":"http://39.99.158.50/categories/java基础/面向对象/"},{"name":"-java基础","slug":"java基础","permalink":"http://39.99.158.50/categories/java基础/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://39.99.158.50/tags/docker/"},{"name":"linux","slug":"linux","permalink":"http://39.99.158.50/tags/linux/"},{"name":"jdk","slug":"jdk","permalink":"http://39.99.158.50/tags/jdk/"},{"name":"live2d","slug":"live2d","permalink":"http://39.99.158.50/tags/live2d/"},{"name":"hexo","slug":"hexo","permalink":"http://39.99.158.50/tags/hexo/"},{"name":"-live2d -hexo","slug":"live2d-hexo","permalink":"http://39.99.158.50/tags/live2d-hexo/"},{"name":"主题","slug":"主题","permalink":"http://39.99.158.50/tags/主题/"},{"name":"-hexo","slug":"hexo","permalink":"http://39.99.158.50/tags/hexo/"},{"name":"eclipse","slug":"eclipse","permalink":"http://39.99.158.50/tags/eclipse/"},{"name":"java","slug":"java","permalink":"http://39.99.158.50/tags/java/"},{"name":"算法","slug":"算法","permalink":"http://39.99.158.50/tags/算法/"},{"name":"数组","slug":"数组","permalink":"http://39.99.158.50/tags/数组/"},{"name":"二维数组","slug":"二维数组","permalink":"http://39.99.158.50/tags/二维数组/"},{"name":"java基础","slug":"java基础","permalink":"http://39.99.158.50/tags/java基础/"},{"name":"面向对象","slug":"面向对象","permalink":"http://39.99.158.50/tags/面向对象/"},{"name":"-java","slug":"java","permalink":"http://39.99.158.50/tags/java/"},{"name":"-博客","slug":"博客","permalink":"http://39.99.158.50/tags/博客/"}]}